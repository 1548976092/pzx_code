//注释了加载fpga部分代码

/* Autogenerated by /home/pi/new/linuxcnc-master/bin/halcompile on Sat Oct 12 14:07:37 2019 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#include "rtapi_math.h"
#include "hal/drivers/pluto_common.h"
#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:pluto_step:Hardware driver and firmware for the Pluto-P parallel-port FPGA, for use with stepper machines.\n\n.B loadrt pluto_step ioaddr=\\fIaddr\\fB ioaddr_hi=\\fIaddr\\fB epp_wide=\\fI[0|1]\\fB\n\n.RS 4\n.TP\n\\fBioaddr\\fR [default: 0x378]\nThe base address of the parallel port.\n\n.TP\n\\fBioaddr_hi\\fR [default: 0]\nThe secondary address of the parallel port, used to set EPP\nmode.  0 means to use ioaddr + 0x400.  -1 means there is no\nsecondary address.\n\n.TP\n\\fBepp_wide\\fR [default: 1]\nSet to zero to disable \"wide EPP mode\".  \"Wide\" mode allows 16- and 32-bit EPP\ntransfers, which can reduce the time spent in the read and write functions.\nHowever, this mode may not work on all EPP parallel ports.\n\n.TP\n\\fBwatchdog\\fR [default: 1]\nSet to zero to disable the \"hardware watchdog\".  \"Watchdog\" will tristate all\noutputs approximately 6ms after the last execution of\n\\fBpluto-step.write\\fR, which adds some protection in the case of LinuxCNC\ncrashes.\n\n.TP\n\\fBspeedrange\\fR [default: 0]\nSelects one of four speed ranges:\n.RS\n.RS 4\n.TQ\n0: Top speed 312.5kHz; minimum speed 610Hz\n.TQ\n1: Top speed 156.25kHz; minimum speed 305Hz\n.TQ\n2: Top speed 78.125kHz; minimum speed 153Hz\n.TQ\n3: Top speed 39.06kHz; minimum speed 76Hz\n.RE\nChoosing the smallest maximum speed that is above the maximum for any one axis\nmay give improved step regularity at low step speeds.\n.RE\n.RE");
MODULE_INFO(linuxcnc, "descr:\nPluto_step is a LinuxCNC software driver and associated firmware that allow the Pluto-P board to be used to control a stepper-based CNC machine.\n\nThe driver has 4 step+direction channels, 14 dedicated digital outputs, and 16\ndedicated digital inputs.\n\n.SS Step generators\nThe step generator takes a position input and output.\n\nThe step waveform includes step length/space and direction hold/setup time.\nStep length and direction setup/hold time is enforced in the FPGA.  Step space\nis enforced by a velocity cap in the driver.\n\n\\fI(all the following numbers are subject to change)\\fR\nIn \\fIspeedrange=0\\fR, the maximum step rate is 312.5kHz.  For position\nfeedback to be accurate, the maximum step rate is 512 pulses per servo cycle\n(so a 1kHz servo cycle does not impose any additional limitation).  The maximum\nstep rate may be lowered by the step length and space parameters, which are\nrounded up to the nearest multiple of 1600ns.\n\nIn successive speedranges the maximum step rate is divided in half, as is the\nmaximum steps per servo cycle, and the minimum nonzero step rate.\n\n.SS Digital I/O\nThe digital output pins conform to the `canonical digital output' interface\ndescribed in the HAL manual.\n\nThe digital input pins conform to the `canonical digital input' interface\ndescribed in the HAL manual.\n");
MODULE_INFO(linuxcnc, "pin:stepgen.#.position-cmd:float:4:in::None:None");
MODULE_INFO(linuxcnc, "pin:stepgen.#.velocity-fb:float:4:out::None:None");
MODULE_INFO(linuxcnc, "pin:stepgen.#.position-fb:float:4:out::None:None");
MODULE_INFO(linuxcnc, "pin:stepgen.#.counts:s32:4:out::None:None");
MODULE_INFO(linuxcnc, "pin:stepgen.#.enable:bit:4:in::None:None");
MODULE_INFO(linuxcnc, "pin:stepgen.#.reset:bit:4:in:When TRUE, reset position-fb to 0:None:None");
MODULE_INFO(linuxcnc, "param:stepgen.#.scale:float:4:rw::1.0:None");
MODULE_INFO(linuxcnc, "param:stepgen.#.maxvel:float:4:rw::0:None");
MODULE_INFO(linuxcnc, "param:stepgen.step_polarity:bit:0:rw::None:None");
MODULE_INFO(linuxcnc, "param:stepgen.steplen:u32:0:rw:Step length in ns.:None:None");
MODULE_INFO(linuxcnc, "param:stepgen.stepspace:u32:0:rw:Step space in ns:None:None");
MODULE_INFO(linuxcnc, "param:stepgen.dirtime:u32:0:rw:Dir hold/setup in ns.  Refer to the pdf documentation for a diagram of what these timings mean.:None:None");
MODULE_INFO(linuxcnc, "pin:dout.##:bit:14:in:dout.\\fIMM\\fR corresponds to the pin labeled\nOUT\\fIM\\fR on the pinout diagram.:None:None");
MODULE_INFO(linuxcnc, "param:dout.##-invert:bit:14:rw:If TRUE, the output on the corresponding \\fBdout.\\fIMM\\fR is inverted.:None:None");
MODULE_INFO(linuxcnc, "pin:din.##:bit:16:out::None:None");
MODULE_INFO(linuxcnc, "pin:din.##_not:bit:16:out:din.\\fIMM\\fR corresponds to the pin labeled\nIN\\fIM\\fR on the pinout diagram.:None:None");
MODULE_INFO(linuxcnc, "param:communication_error:u32:0:rw:Incremented each time \npluto-step.read detects an error code in the EPP status register.  While\nthis register is nonzero, new values are not being written to the Pluto-P\nboard, and the status of digital outputs and the PWM duty cycle of the PWM\noutputs will remain unchanged.  If the hardware watchdog is enabled, it will\nactivate shortly after the communication error is detected by LinuxCNC.  To continue\nafter a communication error, set this parameter back to zero.:None:None");
MODULE_INFO(linuxcnc, "param:debug_0:s32:0:rw::None:None");
MODULE_INFO(linuxcnc, "param:debug_1:s32:0:rw::None:None");
MODULE_INFO(linuxcnc, "param:debug_2:float:0:rw::.5:None");
MODULE_INFO(linuxcnc, "param:debug_3:float:0:rw:Registers that hold debugging information of interest to developers:2.0:None");
MODULE_INFO(linuxcnc, "funct:read:1:Read all the inputs from the pluto-step board");
MODULE_INFO(linuxcnc, "funct:write:1:Write all the outputs on the pluto-step board");
MODULE_INFO(linuxcnc, "see_also:The \\fIpluto_step\\fR section in the HAL User Manual, which shows the location of each physical pin on the pluto board.");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_float_t *stepgen_position_cmd[4];
    hal_float_t *stepgen_velocity_fb[4];
    hal_float_t *stepgen_position_fb[4];
    hal_s32_t *stepgen_counts[4];
    hal_bit_t *stepgen_enable[4];
    hal_bit_t *stepgen_reset[4];
    hal_bit_t *dout[14];
    hal_bit_t *din[16];
    hal_bit_t *din_not[16];
    hal_float_t stepgen_scale[4];
    hal_float_t stepgen_maxvel[4];
    hal_bit_t stepgen_step_polarity;
    hal_u32_t stepgen_steplen;
    hal_u32_t stepgen_stepspace;
    hal_u32_t stepgen_dirtime;
    hal_bit_t dout_invert[14];
    hal_u32_t communication_error;
    hal_s32_t debug_0;
    hal_s32_t debug_1;
    hal_float_t debug_2;
    hal_float_t debug_3;
    void *_data;
};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void read(struct __comp_state *__comp_inst, long period);
static void write(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg);
static void extra_cleanup(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int j = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    inst->_data = (char*)inst + sizeof(struct __comp_state);
    r = extra_setup(inst, prefix, extra_arg);
    if(r != 0) return r;
    for(j=0; j < (4); j++) {
        r = hal_pin_float_newf(HAL_IN, &(inst->stepgen_position_cmd[j]), comp_id,
            "%s.stepgen.%01d.position-cmd", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (4); j++) {
        r = hal_pin_float_newf(HAL_OUT, &(inst->stepgen_velocity_fb[j]), comp_id,
            "%s.stepgen.%01d.velocity-fb", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (4); j++) {
        r = hal_pin_float_newf(HAL_OUT, &(inst->stepgen_position_fb[j]), comp_id,
            "%s.stepgen.%01d.position-fb", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (4); j++) {
        r = hal_pin_s32_newf(HAL_OUT, &(inst->stepgen_counts[j]), comp_id,
            "%s.stepgen.%01d.counts", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (4); j++) {
        r = hal_pin_bit_newf(HAL_IN, &(inst->stepgen_enable[j]), comp_id,
            "%s.stepgen.%01d.enable", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (4); j++) {
        r = hal_pin_bit_newf(HAL_IN, &(inst->stepgen_reset[j]), comp_id,
            "%s.stepgen.%01d.reset", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (14); j++) {
        r = hal_pin_bit_newf(HAL_IN, &(inst->dout[j]), comp_id,
            "%s.dout.%02d", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (16); j++) {
        r = hal_pin_bit_newf(HAL_OUT, &(inst->din[j]), comp_id,
            "%s.din.%02d", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (16); j++) {
        r = hal_pin_bit_newf(HAL_OUT, &(inst->din_not[j]), comp_id,
            "%s.din.%02d-not", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (4); j++) {
        r = hal_param_float_newf(HAL_RW, &(inst->stepgen_scale[j]), comp_id,
            "%s.stepgen.%01d.scale", prefix, j);
        if(r != 0) return r;
    inst->stepgen_scale[j] = 1.0;
    }
    for(j=0; j < (4); j++) {
        r = hal_param_float_newf(HAL_RW, &(inst->stepgen_maxvel[j]), comp_id,
            "%s.stepgen.%01d.maxvel", prefix, j);
        if(r != 0) return r;
    inst->stepgen_maxvel[j] = 0;
    }
    r = hal_param_bit_newf(HAL_RW, &(inst->stepgen_step_polarity), comp_id,
        "%s.stepgen.step-polarity", prefix);
    if(r != 0) return r;
    r = hal_param_u32_newf(HAL_RW, &(inst->stepgen_steplen), comp_id,
        "%s.stepgen.steplen", prefix);
    if(r != 0) return r;
    r = hal_param_u32_newf(HAL_RW, &(inst->stepgen_stepspace), comp_id,
        "%s.stepgen.stepspace", prefix);
    if(r != 0) return r;
    r = hal_param_u32_newf(HAL_RW, &(inst->stepgen_dirtime), comp_id,
        "%s.stepgen.dirtime", prefix);
    if(r != 0) return r;
    for(j=0; j < (14); j++) {
        r = hal_param_bit_newf(HAL_RW, &(inst->dout_invert[j]), comp_id,
            "%s.dout.%02d-invert", prefix, j);
        if(r != 0) return r;
    }
    r = hal_param_u32_newf(HAL_RW, &(inst->communication_error), comp_id,
        "%s.communication-error", prefix);
    if(r != 0) return r;
    r = hal_param_s32_newf(HAL_RW, &(inst->debug_0), comp_id,
        "%s.debug-0", prefix);
    if(r != 0) return r;
    r = hal_param_s32_newf(HAL_RW, &(inst->debug_1), comp_id,
        "%s.debug-1", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->debug_2), comp_id,
        "%s.debug-2", prefix);
    inst->debug_2 = .5;
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->debug_3), comp_id,
        "%s.debug-3", prefix);
    inst->debug_3 = 2.0;
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s.read", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))read, inst, 1, 0, comp_id);
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s.write", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))write, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
int rtapi_app_main(void) {
    int r = 0;
    comp_id = hal_init("pluto_step");
    if(comp_id < 0) return comp_id;
    r = export("pluto-step", 0);
    if(r) {
    extra_cleanup();
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    extra_cleanup();
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef stepgen_position_cmd
#define stepgen_position_cmd(i) (0+*(__comp_inst->stepgen_position_cmd[i]))
#undef stepgen_velocity_fb
#define stepgen_velocity_fb(i) (*(__comp_inst->stepgen_velocity_fb[i]))
#undef stepgen_position_fb
#define stepgen_position_fb(i) (*(__comp_inst->stepgen_position_fb[i]))
#undef stepgen_counts
#define stepgen_counts(i) (*(__comp_inst->stepgen_counts[i]))
#undef stepgen_enable
#define stepgen_enable(i) (0+*(__comp_inst->stepgen_enable[i]))
#undef stepgen_reset
#define stepgen_reset(i) (0+*(__comp_inst->stepgen_reset[i]))
#undef dout
#define dout(i) (0+*(__comp_inst->dout[i]))
#undef din
#define din(i) (*(__comp_inst->din[i]))
#undef din_not
#define din_not(i) (*(__comp_inst->din_not[i]))
#undef stepgen_scale
#define stepgen_scale(i) (__comp_inst->stepgen_scale[i])
#undef stepgen_maxvel
#define stepgen_maxvel(i) (__comp_inst->stepgen_maxvel[i])
#undef stepgen_step_polarity
#define stepgen_step_polarity (__comp_inst->stepgen_step_polarity)
#undef stepgen_steplen
#define stepgen_steplen (__comp_inst->stepgen_steplen)
#undef stepgen_stepspace
#define stepgen_stepspace (__comp_inst->stepgen_stepspace)
#undef stepgen_dirtime
#define stepgen_dirtime (__comp_inst->stepgen_dirtime)
#undef dout_invert
#define dout_invert(i) (__comp_inst->dout_invert[i])
#undef communication_error
#define communication_error (__comp_inst->communication_error)
#undef debug_0
#define debug_0 (__comp_inst->debug_0)
#undef debug_1
#define debug_1 (__comp_inst->debug_1)
#undef debug_2
#define debug_2 (__comp_inst->debug_2)
#undef debug_3
#define debug_3 (__comp_inst->debug_3)
#undef data
#define data (*(internal*)(__comp_inst->_data))


#line 148 "pluto_step.comp"

static int speedrange=0;
RTAPI_MP_INT(speedrange, "Speed range 0..3");

#define PLUTO_SPEED_NS (1600)
#define PLUTO_SPEED    (PLUTO_SPEED_NS * 1e-9)
#define PLUTO_FREQ     (1e9 / PLUTO_SPEED_NS)
#define TMAX           ((1<<5)-1)

#define W 10
#define F 11
#define MODULO ((1<<(W+F))-1)
#define MASK ((1<<(W+F))-1)
#define MAXDELTA (MASK/2)

typedef struct {
    int64_t last_count[4];
    int64_t reset_count[4];
    double old_position_cmd[4];
    double old_velocity_cmd[4];
} internal;

#define ONE (1<<F)
#define MAX_STEP_RATE (1<<(F-1))
FUNCTION(write) {
    int r = 0;
    int i;
    int stepspace_ticks = stepgen_stepspace/PLUTO_SPEED_NS;
    int steplen_ticks = stepgen_steplen/PLUTO_SPEED_NS;
    int dirtime_ticks = stepgen_dirtime/PLUTO_SPEED_NS;
    int rate, maxrate = MAX_STEP_RATE;
    double fmax;

    if(steplen_ticks > TMAX) {
        steplen_ticks = TMAX;
        rtapi_print_msg(RTAPI_MSG_ERR,
            "Requested step length %dns decreased to %dns "
            "due to hardware limitations\n",
            stepgen_steplen, TMAX * PLUTO_SPEED_NS);
        stepgen_steplen = TMAX * PLUTO_SPEED_NS;
    }

    if(dirtime_ticks > TMAX) {
        dirtime_ticks = TMAX;
        rtapi_print_msg(RTAPI_MSG_ERR,
            "Requested direction change time %dns decreased to %dns "
            "due to hardware limitations\n",
            stepgen_dirtime, TMAX * PLUTO_SPEED_NS);
        stepgen_dirtime = TMAX * PLUTO_SPEED_NS;
    }

    // Speed limits come from several sources
    // First limit: step waveform timings
    fmax = 1. / PLUTO_SPEED / (2 + steplen_ticks + stepspace_ticks);
    // Second limit: highest speed command
    if(fmax > PLUTO_FREQ / (2<<speedrange))
        fmax = PLUTO_SPEED * (2<<speedrange);
    // Third limit: max sign-extenable counts per period
    if(fmax > MAXDELTA / fperiod / (1<<speedrange))
        fmax = MAXDELTA / fperiod / (1<<speedrange);

    if(communication_error) return;

    EPP_ADDR(0);

    for(i=0; i<4; i++) {
	double new_position_cmd = stepgen_position_cmd(i);
	double v = new_position_cmd - data.old_position_cmd[i];
	double est_err = stepgen_position_fb(i) + data.old_velocity_cmd[i] * fperiod - new_position_cmd;
        double actual_max;
	double scale_abs = fabs(stepgen_scale(i));

	v = v - debug_2 * est_err / fperiod;
        if(v > 0) v = v + .5/scale_abs;
        else if(v < 0) v = v - .5/scale_abs;

	data.old_position_cmd[i] = new_position_cmd;
	data.old_velocity_cmd[i] = v;
        actual_max = fmax / scale_abs;
        if(stepgen_maxvel(i) < 0) stepgen_maxvel(i) = -stepgen_maxvel(i);
        if(stepgen_maxvel(i) != 0 && stepgen_maxvel(i) > actual_max) {
            static int message_printed[4] = {0,0,0,0};
            if(!message_printed[i]) {
                rtapi_print_msg(RTAPI_MSG_ERR,
                    "Requested step rate %dHz decreased to %dHz "
                    "due to hardware or timing limitations\n",
                    (int)(stepgen_maxvel(i) * scale_abs),
                    (int)(fmax));
                message_printed[i] = 1;
            }
            stepgen_maxvel(i) = actual_max;
        }

        if(stepgen_maxvel(i) == 0) {
            if(v < -actual_max) v = -actual_max;
            if(v > actual_max) v = actual_max;
        } else {
            if(v < -stepgen_maxvel(i)) v = -stepgen_maxvel(i);
            if(v > stepgen_maxvel(i)) v = stepgen_maxvel(i);
        }
	rate = v * stepgen_scale(i) * ONE * PLUTO_SPEED / (1<<speedrange);

	if(rate > maxrate) rate = maxrate;
	if(rate < -maxrate) rate = -maxrate;

	if(!stepgen_enable(i)) rate = 0;
        if(i == 0) debug_1 = rate;
	write16(rate);
    }

    r = 0;
    for(i=0; i<14; i++) {
        if(!dout(i) ^ !dout_invert(i)) r |= (1<<i);
    }
    write16(r);

    r = steplen_ticks | (dirtime_ticks << 8);
    if (stepgen_step_polarity) r |= 0x8000;
    write16(r);
}


FUNCTION(read) {
    int i;
    __u32 ppdata;

    EPP_ADDR(0);
    EPP_DIR_READ();

    for(i=0; i<4; i++) {
        int64_t count;
        double fcount;
	int newlow;
        int reset;
        ppdata = read32();
        reset = stepgen_reset(i);
        if(i == 0) {
            int status = inb(ioaddr+1) & 1;
            if(status) {
                communication_error ++;
		pluto_clear_error_register();
            }
            if(communication_error) { 
		//EPP_DIR_WRITE(); return;
	 }
        }

	newlow = ppdata & MASK;

        count = extend(data.last_count[i], newlow, W+F);
	stepgen_velocity_fb(i) = (count - data.last_count[i]) / stepgen_scale(i) / fperiod / (1 << F);
        data.last_count[i] = count;
        if(reset) data.reset_count[i] = count;
        fcount = (count - data.reset_count[i]) * 1. / (1<<F);
        stepgen_counts(i) = fcount;
        stepgen_position_fb(i) = fcount / stepgen_scale(i);

        if(i == 0) { debug_0 = ppdata; }
    }

    ppdata = read32();

    for(i=0; i<16; i++) {
        int b = ppdata & (1<<i);
        din(i) = !!b; din_not(i) = !b;
    }

//    EPP_DIR_WRITE();
}

//#include "hal/drivers/pluto_step_rbf.h"

EXTRA_SETUP() {
//    return pluto_setup(firmware);
return 0;
}

EXTRA_CLEANUP() {
//    pluto_cleanup();
}

// vim:sts=4:sw=4:et

static int __comp_get_data_size(void) { return sizeof(internal); }
