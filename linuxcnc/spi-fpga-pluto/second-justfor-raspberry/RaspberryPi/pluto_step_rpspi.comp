/*   This is a component of pluto_step_rpspi for RaspberryPi , a stepper driver over SPI for linuxcnc. *    Copyright 2013 Matsche <tinker@play-pla.net> * 		based on GP Orcullo's picnc driver and * 		based on the pluto_step.comp from Jeff Epler <jepler@unpythonic.net> *// This program is free software; you can redistribute it and/or modify// it under the terms of the GNU General Public License as published by// the Free Software Foundation; either version 2 of the License, or// (at your option) any later version.//// This program is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the// GNU General Public License for more details.//// You should have received a copy of the GNU General Public License// along with this program; if not, write to the Free Software// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA */component pluto_step_rpspi """Hardware driver and firmware for the Pluto-P parallel-port FPGA, for use with stepper machines.and RaspberryPi SPI .""";description """Pluto_step is a LinuxCNC software driver and associated firmware that allow the Pluto-P board to be used to control a stepper-based CNC machine.The driver has 4 step+direction channels, 14 dedicated digital outputs, and 16dedicated digital inputs..SS Step generatorsThe step generator takes a position input and output.The step waveform includes step length/space and direction hold/setup time.Step length and direction setup/hold time is enforced in the FPGA.  Step spaceis enforced by a velocity cap in the driver.\\fI(all the following numbers are subject to change)\\fRIn \\fIspeedrange=0\\fR, the maximum step rate is 312.5kHz.  For positionfeedback to be accurate, the maximum step rate is 512 pulses per servo cycle(so a 1kHz servo cycle does not impose any additional limitation).  The maximumstep rate may be lowered by the step length and space parameters, which arerounded up to the nearest multiple of 1600ns.In successive speedranges the maximum step rate is divided in half, as is themaximum steps per servo cycle, and the minimum nonzero step rate..SS Digital I/OThe digital output pins conform to the `canonical digital output' interfacedescribed in the HAL manual.The digital input pins conform to the `canonical digital input' interfacedescribed in the HAL manual.""";pin in float stepgen.#.position-cmd[4];pin out float stepgen.#.velocity-fb[4];pin out float stepgen.#.position-fb[4];pin out s32 stepgen.#.counts[4];pin in bit stepgen.#.enable[4];pin in bit stepgen.#.reset[4] "When TRUE, reset position-fb to 0";param rw float stepgen.#.scale[4] = 1.0;param rw float stepgen.#.maxvel[4] = 0;param rw bit stepgen.step_polarity;param rw u32 stepgen.steplen "Step length in ns.";param rw u32 stepgen.stepspace "Step space in ns";param rw u32 stepgen.dirtime "Dir hold/setup in ns.  Refer to the pdf documentation for a diagram of what these timings mean.";pin in bit dout.##[14]"""dout.\\fIMM\\fR corresponds to the pin labeledOUT\\fIM\\fR on the pinout diagram.""";param rw bit dout.##-invert[14]"If TRUE, the output on the corresponding \\fBdout.\\fIMM\\fR is inverted.";pin out bit din.##[16];pin out bit din.##_not[16]"""din.\\fIMM\\fR corresponds to the pin labeledIN\\fIM\\fR on the pinout diagram.""";param rw u32 communication_error """Incremented each time pluto-step.read detects an error code in the EPP status register.  Whilethis register is nonzero, new values are not being written to the Pluto-Pboard, and the status of digital outputs and the PWM duty cycle of the PWMoutputs will remain unchanged.  If the hardware watchdog is enabled, it willactivate shortly after the communication error is detected by LinuxCNC.  To continueafter a communication error, set this parameter back to zero.""";param rw s32 debug_0;param rw s32 debug_1;param rw float debug_2=.5;param rw float debug_3=2.0 """Registers that hold debugging information of interest to developers""";option singleton;option extra_setup;option extra_cleanup;option data internal;see_also """The \\fIpluto_step\\fR section in the HAL User Manual, which shows the location of each physical pin on the pluto board.""";function transfer  "transfers data between master and slave devices";function spitest "test spi transfer (only for developers)";license "GPL";author "Matsche";;;#include "rtapi.h"#include "rtapi_bitops.h"#include "rtapi_app.h"#include "hal.h"#define BUILD_SYS_USER_DSO#define TARGET_PLATFORM_RASPBERRY#if !defined(BUILD_SYS_USER_DSO)#error "This driver is for usermode threads only"#endif#if !defined(TARGET_PLATFORM_RASPBERRY)#error "This driver is for the Raspberry Pi platform only"#endif#define u32 unsigned int #define __u32 unsigned int#define u16 unsigned short#define __u16 unsigned short #include <stdio.h>#include <stdlib.h>#include <stdint.h>#include <math.h>#include <fcntl.h>#include <sys/mman.h>#include <sys/types.h>#include <sys/stat.h>#include <unistd.h>#include <errno.h>#include <stdarg.h>#include "pluto_common_rpspi.h"volatile unsigned *gpio, *spi;static volatile u32 txBuf[BUFSIZE], rxBuf[BUFSIZE];static platform_t platform;static int map_gpio();static void setup_gpio();static void restore_gpio();static int pluto_program(char *);platform_t check_platform(void);static int speedrange=0;RTAPI_MP_INT(speedrange, "Speed range 0..3");#define PLUTO_SPEED_NS (1600)#define PLUTO_SPEED    (PLUTO_SPEED_NS * 1e-9)#define PLUTO_FREQ     (1e9 / PLUTO_SPEED_NS)#define TMAX           ((1<<5)-1)#define W 10#define F 11#define MODULO ((1<<(W+F))-1)#define MASK ((1<<(W+F))-1)#define MAXDELTA (MASK/2)typedef struct {	int64_t last_count[4];	int64_t reset_count[4];	double old_position_cmd[4];	double old_velocity_cmd[4];} internal;#define ONE (1<<F)#define MAX_STEP_RATE ((1<<F)-1)EXTRA_SETUP() {	int i, retval = 0;	platform = check_platform();	retval = map_gpio();	if (retval < 0) {		rtapi_print_msg(RTAPI_MSG_ERR,		        "HAL_pluto_servo_rpspi: ERROR: cannot map GPIO memory\n");		return retval;	}	if(firmware != "")	{		retval = pluto_program(firmware);		if(retval < 0)		{			rtapi_print_msg(RTAPI_MSG_ERR,					"HAL_pluto_servo_rpspi: ERROR: uploading firmware failed!!!\n");			return retval;		}	}        	setup_gpio();	return 0;}EXTRA_CLEANUP() {	// reset the FPGA	GPIO_CLR = 1<<25;	usleep(1000);	GPIO_SET = 1<<25;	usleep(1000);	if (gpio != MAP_FAILED && spi != MAP_FAILED) {				restore_gpio();		munmap((void *)gpio,BLOCK_SIZE);		munmap((void *)spi,BLOCK_SIZE);	}}FUNCTION(spitest) {	char *buf;	int i;	__u32 spidata;		for (i=0; i<BUFSIZE; i++) {		txBuf[i] = i;	}		/* activate transfer */	BCM2835_SPICS = SPI_CS_TA|SPI_CS_CPHA;	/* send txBuf */	/* RPi SPI transfers 8 bits at a time only */	buf = (char *)txBuf;	for (i=0; i<SPIBUFSIZE; i++) {		BCM2835_SPIFIFO = *buf++;	}	/* wait until transfer is finished */	while (!(BCM2835_SPICS & SPI_CS_DONE));	/* clear DONE bit */	BCM2835_SPICS = SPI_CS_DONE;	/*****************************************************************************/	/* read buffer */	/* RPi SPI transfers 8 bits at a time only */	buf = (char *)rxBuf;	for (i=0; i<SPIBUFSIZE; i++) {		*buf++ = BCM2835_SPIFIFO;	}		for (i=5; i<BUFSIZE; i++) {		spidata = rxBuf[i];	}}	FUNCTION(transfer) {	char *buf;	__u16 * tbuf;		int i;	__u32 spidata;	//rtapi_print_msg(RTAPI_MSG_ERR,	//		"HAL_pluto_servo_rpspi: START transfer!!!\n");	int r = 0;	int stepspace_ticks = stepgen_stepspace/PLUTO_SPEED_NS;	int steplen_ticks = stepgen_steplen/PLUTO_SPEED_NS;	int dirtime_ticks = stepgen_dirtime/PLUTO_SPEED_NS;	int rate, maxrate = MAX_STEP_RATE;	double fmax;	if(steplen_ticks > TMAX) {		steplen_ticks = TMAX;		rtapi_print_msg(RTAPI_MSG_ERR,				"Requested step length %dns decreased to %dns "				"due to hardware limitations\n",				stepgen_steplen, TMAX * PLUTO_SPEED_NS);		stepgen_steplen = TMAX * PLUTO_SPEED_NS;	}	if(dirtime_ticks > TMAX) {		dirtime_ticks = TMAX;		rtapi_print_msg(RTAPI_MSG_ERR,				"Requested direction change time %dns decreased to %dns "				"due to hardware limitations\n",				stepgen_dirtime, TMAX * PLUTO_SPEED_NS);		stepgen_dirtime = TMAX * PLUTO_SPEED_NS;	}	// Speed limits come from several sources	// First limit: step waveform timings	fmax = 1.0 / PLUTO_SPEED / (2 + steplen_ticks + stepspace_ticks);	// Second limit: highest speed command	if(fmax > PLUTO_FREQ / (2<<speedrange))			fmax = PLUTO_SPEED * (2<<speedrange);	// Third limit: max sign-extenable counts per period	if(fmax > MAXDELTA / fperiod / (1<<speedrange))			fmax = MAXDELTA / fperiod / (1<<speedrange);	//if(communication_error) return;		tbuf = (__u16 *)txBuf;	for(i=0; i<4; i++) {		double new_position_cmd = stepgen_position_cmd(i);		double v = new_position_cmd - data.old_position_cmd[i];		double est_err = stepgen_position_fb(i) + data.old_velocity_cmd[i] * fperiod - new_position_cmd;		double actual_max;		double scale_abs = abs(stepgen_scale(i));		v = v - debug_2 * est_err / fperiod;		if(v > 0) v = v + .5/scale_abs;		else if(v < 0) v = v - .5/scale_abs;		data.old_position_cmd[i] = new_position_cmd;		data.old_velocity_cmd[i] = v;		actual_max = fmax / scale_abs;		if(stepgen_maxvel(i) < 0) stepgen_maxvel(i) = -stepgen_maxvel(i);		if(stepgen_maxvel(i) != 0 && stepgen_maxvel(i) > actual_max) {			static int message_printed[4] = {0,0,0,0};			if(!message_printed[i]) {				rtapi_print_msg(RTAPI_MSG_ERR,						"Requested step rate %dHz decreased to %dHz "						"due to hardware or timing limitations\n",						(int)(stepgen_maxvel(i) * scale_abs),						(int)(fmax));				message_printed[i] = 1;			}			stepgen_maxvel(i) = actual_max;		}		if(stepgen_maxvel(i) == 0) {			if(v < -actual_max) v = -actual_max;			if(v > actual_max) v = actual_max;		}else {			if(v < -stepgen_maxvel(i)) v = -stepgen_maxvel(i);			if(v > stepgen_maxvel(i)) v = stepgen_maxvel(i);		}		rate = v*stepgen_scale(i)*ONE*PLUTO_SPEED/(1<<speedrange);		if(rate > maxrate) rate = maxrate;		if(rate < -maxrate) rate = -maxrate;		if(!stepgen_enable(i)) rate = 0;		//if(i == 0) debug_1 = rate;		//if(!i%2)		//	txBuf[i%2] = 0;		//txBuf[i%2] |= rate<<(16*(i%2));		tbuf[i] = rate;	}	r = 0;	for(i=0; i<14; i++) {		if(!dout(i) ^ !dout_invert(i)) r |= (1<<i);	}	txBuf[2] = r;	r=0;	r = steplen_ticks | (dirtime_ticks << 8);	//r = steplen_ticks+stepspace_ticks | (dirtime_ticks << 8);	if (stepgen_step_polarity) {			r |= 0x8000;	}else r &= 0x7FFF;	txBuf[2] |= r<<16;		for (i=3; i<BUFSIZE; i++) {		txBuf[i] = i;	}		/* activate transfer */	BCM2835_SPICS = SPI_CS_TA|SPI_CS_CPHA;	/* send txBuf */	/* RPi SPI transfers 8 bits at a time only */	buf = (char *)txBuf;	for (i=0; i<SPIBUFSIZE; i++) {		BCM2835_SPIFIFO = *buf++;	}	/* wait until transfer is finished */	while (!(BCM2835_SPICS & SPI_CS_DONE));	/* clear DONE bit */	BCM2835_SPICS = SPI_CS_DONE;	/*****************************************************************************/	/* read buffer */	/* RPi SPI transfers 8 bits at a time only */	buf = (char *)rxBuf;	for (i=0; i<SPIBUFSIZE; i++) {		*buf++ = BCM2835_SPIFIFO;	}		for(i=0; i<4; i++) {		int64_t count;		double fcount;		int newlow;		int reset;				spidata = rxBuf[i];				reset = stepgen_reset(i);		newlow = spidata & MASK;		count = extend(data.last_count[i], newlow, W+F);		stepgen_velocity_fb(i) = (count-data.last_count[i])/stepgen_scale(i)/fperiod/(1<<F);		data.last_count[i] = count;		if(reset) data.reset_count[i] = count;		fcount = (count-data.reset_count[i])*1.0/(1<<F);		stepgen_counts(i) = fcount;		stepgen_position_fb(i) = fcount/stepgen_scale(i);		if(i == 0) {		//		debug_0 = spidata;			debug_1 = newlow;		}	}	spidata = rxBuf[4];	debug_0 = spidata; //din	//debug_1 = spidata;	for(i=0; i< 16; i++) {		int b = spidata & (1<<i);		din(i) = !!b;		din_not(i) = !b;	}		for (i=5; i<BUFSIZE; i++) {		spidata = rxBuf[i];	}	//rtapi_print_msg(RTAPI_MSG_ERR,	//		"HAL_pluto_servo_rpspi: END transfer!!!\n");}int map_gpio() {	int fd;	static u32 mem_base, mem_spi_base;	switch (platform) {	case RPI:		mem_base = BCM2835_GPIO_BASE;		mem_spi_base = BCM2835_SPI_BASE;		break;	case RPI_2:		mem_base = BCM2835_GPIO_BASE + BCM2709_OFFSET;		mem_spi_base = BCM2835_SPI_BASE + BCM2709_OFFSET;		break;	default:		rtapi_print_msg(RTAPI_MSG_ERR,			"HAL_pluto_servo_rpspi: Not Support!!\n");		break;	}	fd = rtapi_open_as_root("/dev/mem", O_RDWR | O_SYNC);	if (fd < 0) {		rtapi_print_msg(RTAPI_MSG_ERR,"HAL_pluto_servo_rpspi: can't open /dev/mem \n");		return -1;	}	/* mmap GPIO */	gpio = mmap(	        NULL,	        BLOCK_SIZE,	        PROT_READ|PROT_WRITE,	        MAP_SHARED,	        fd,	        mem_base);	/* mmap SPI */	spi = mmap(	        NULL,	        BLOCK_SIZE,	        PROT_READ|PROT_WRITE,	        MAP_SHARED,	        fd,	        mem_spi_base);	close(fd);	if (gpio == MAP_FAILED) {		rtapi_print_msg(RTAPI_MSG_ERR,"HAL_pluto_servo_rpspi: can't map gpio\n");		return -2;	}	if (spi == MAP_FAILED) {		rtapi_print_msg(RTAPI_MSG_ERR,"HAL_pluto_servo_rpspi: can't map spi\n");		return -3;	}	return 0;}void setup_gpio() {	uint32_t x;	/* change SPI pins */	x = BCM2835_GPFSEL0;	//x &= ~(0b111 << (7*3) | 0b111 << (8*3) | 0b111 << (9*3));	//x |= (0b001 << (7*3) | 0b100 << (8*3) | 0b100 << (9*3));	// GPIO pin7 output, pin8 pin9 alternate0 (SPI)	x &= ~(0b111 << (8*3) | 0b111 << (9*3));	x |= (0b100 << (8*3) | 0b100 << (9*3));	// pin8 pin9 alternate0 (SPI)	BCM2835_GPFSEL0 = x;	x = BCM2835_GPFSEL1;	x &= ~(0b111 << (0*3) | 0b111 << (1*3));	x |= (0b100 << (0*3) | 0b100 << (1*3));	// pin10 pin11 alternate0 (SPI)	BCM2835_GPFSEL1 = x;	/* set up SPI */	BCM2835_SPICLK = (1 << SPICLKDIV);	BCM2835_SPICS = 0;	/* clear FIFOs */	BCM2835_SPICS |= SPI_CS_CLEAR_RX | SPI_CS_CLEAR_TX;	/* clear done bit */	BCM2835_SPICS |= SPI_CS_DONE;}void restore_gpio() {	uint32_t x;	/* change SPI pins to inputs*/	x = BCM2835_GPFSEL0;	//x &= ~(0b111 << (7*3) | 0b111 << (8*3) | 0b111 << (9*3));	x &= ~(0b111 << (8*3) | 0b111 << (9*3));	BCM2835_GPFSEL0 = x;	x = BCM2835_GPFSEL1;	x &= ~(0b111 << (0*3) | 0b111 << (1*3));	BCM2835_GPFSEL1 = x;}#define FIRMWARE_SIZE 19895static int pluto_program(char *firmware) {	int byte, bit;	int i;	FILE *f;	int size = 0;		f= fopen(firmware, "rb");	if(!f) {		rtapi_print_msg(RTAPI_MSG_ERR, "fopen-Error\n");		return -EIO;	}	if(fseek(f, 0, SEEK_END))	{		rtapi_print_msg(RTAPI_MSG_ERR, "fseek-Error!\n");		return -EIO;	}	size = ftell(f);	rewind(f);	rtapi_print_msg(RTAPI_MSG_INFO, "Filesize: %d Bytes\n", size);	if(size != FIRMWARE_SIZE)	{		rtapi_print_msg(RTAPI_MSG_ERR, "Incorrect filesize!!\n");		return -EIO;	}	unsigned char buf[size];	if(fread(buf, 1, size, f) != FIRMWARE_SIZE) {		rtapi_print_msg(RTAPI_MSG_ERR,"fread-Error!\n");		return -EIO;	}			/***************************/	/** Just a extra tuition	**/ 	uint32_t x;	/* setup GPIO 25 as OUTPUT connected to Data2 on Pluto (internal nRESET) */	x = BCM2835_GPFSEL2;		// (25/10)	x &= ~(0b111 << (5*3));	// (25%10*3)	x |= (0b001 << (5*3));	// pin25 OUTPUT	BCM2835_GPFSEL2 = x;		/* setup GPIO 24 as INPUT connected to nPaperOut on Pluto */	x = BCM2835_GPFSEL2;		// (24/10)	x &= ~(0b111 << (4*3));	// (24%10*3) pin24 INPUT	BCM2835_GPFSEL2 = x;	/***************************/		// Set GPIO pins 8-11 to output for Pluto Programming (CE0, MISO, MOSI, SCKL)	for (i=8; i<=11; i++)	{		INP_GPIO(i); // must use INP_GPIO before we can use OUT_GPIO		OUT_GPIO(i);	}			// reset the FPGA in advance	GPIO_CLR = 1<<25;	usleep(1000);	GPIO_SET = 1<<25;	usleep(1000);			rtapi_print_msg(RTAPI_MSG_ERR,"uploading pluto-spi-firmware...\n");	// pull the reset low -- bit 2 of Control register	// keep it low 2 microseconds	for(i=0; i<12; i++) GPIO_CLR = 1<<8;	//outb(0, ioaddr+2);	// let it go high again	// delay 10 microseconds to guarantee nStatus high	for(i=0; i<40; i++) GPIO_SET = 1<<8;	//outb(4, ioaddr+2);	// Now program the device...	for(byte = 0; byte < FIRMWARE_SIZE; byte++) {		for(bit = 0; bit < 8; bit++) {			int v = buf[byte] & (1<<bit);			if(v) GPIO_SET = 1<<10; else GPIO_CLR = 1<<10;			for(i=0; i<22; i++) GPIO_CLR = 1<<11;		//outb(0|4, ioaddr+2);						for(i=0; i<22; i++) GPIO_SET = 1<<11;		//outb(1|4, ioaddr+2);							for(i=0; i<22; i++) GPIO_CLR = 1<<11;		}	}	rtapi_print_msg(RTAPI_MSG_ERR,"...done\n");}platform_t check_platform(void){	FILE *fp;	char buf[2048];	size_t fsize;	platform_t rv;	fp = fopen("/proc/cpuinfo", "r");	fsize = fread(buf, 1, sizeof(buf), fp);	fclose(fp);		if (fsize == 0 || fsize == sizeof(buf))		return 0;	/* NUL terminate the buffer */	buf[fsize] = '\0';	if (NULL != strstr(buf, "BCM2708"))		return RPI;	else if (NULL != strstr(buf, "BCM2709"))		return RPI_2;	else if (NULL != strstr(buf, "BCM2835")){		char *rev_val = strstr(buf, "Revision");		if(rev_val) {			char *rev_start = strstr(rev_val, ": ");			unsigned long rev = strtol(rev_start + 2, NULL, 16);			if(rev <= 0xffff)				rv = RPI; // pre pi2 revision scheme			else {				switch((rev & 0xf000) >> 12) {				case 0: //bcm2835					rv = RPI;					break;				case 1: //bcm2836				case 2: //bcm2837					rv = RPI_2;	// peripheral base is same on pi2/3					break;				default:					break;				}			}		}	}	else		return UNSUPPORTED;	return RPI_2;}