/* Autogenerated by /home/pi/new/linuxcnc-master/bin/halcompile on Thu Nov  7 06:31:31 2019 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:pluto_mix_rpspi:Hardware driver and firmware for the Pluto-P parallel-port FPGA, for use with stepper machines and RaspberryPi SPI .");
MODULE_INFO(linuxcnc, "descr:\nPluto_step is a LinuxCNC software driver and associated firmware that allow the Pluto-P board to be used to control a stepper-based CNC machine.\n\nThe driver has 3 step+direction channels, \n1 encoder channel, 1 pwm channel\n16 dedicated digital outputs, and 16\ndedicated digital inputs.\n\n.SS Step generators\nThe step generator takes a position input and output.\n\nThe step waveform includes step length/space and direction hold/setup time.\nStep length and direction setup/hold time is enforced in the FPGA.  Step space\nis enforced by a velocity cap in the driver.\n\n\\fI(all the following numbers are subject to change)\\fR\nIn \\fIspeedrange=0\\fR, the maximum step rate is 312.5kHz.  For position\nfeedback to be accurate, the maximum step rate is 512 pulses per servo cycle\n(so a 1kHz servo cycle does not impose any additional limitation).  The maximum\nstep rate may be lowered by the step length and space parameters, which are\nrounded up to the nearest multiple of 1600ns.\n\nIn successive speedranges the maximum step rate is divided in half, as is the\nmaximum steps per servo cycle, and the minimum nonzero step rate.\n\n.SS Digital I/O\nThe digital output pins conform to the `canonical digital output' interface\ndescribed in the HAL manual.\n\nThe digital input pins conform to the `canonical digital input' interface\ndescribed in the HAL manual.\n");
MODULE_INFO(linuxcnc, "pin:stepgen.#.position-cmd:float:3:in::None:None");
MODULE_INFO(linuxcnc, "pin:stepgen.#.velocity-fb:float:3:out::None:None");
MODULE_INFO(linuxcnc, "pin:stepgen.#.position-fb:float:3:out::None:None");
MODULE_INFO(linuxcnc, "pin:stepgen.#.counts:s32:3:out::None:None");
MODULE_INFO(linuxcnc, "pin:stepgen.#.enable:bit:3:in::None:None");
MODULE_INFO(linuxcnc, "pin:stepgen.#.reset:bit:3:in:When TRUE, reset position-fb to 0:None:None");
MODULE_INFO(linuxcnc, "param:stepgen.#.scale:float:3:rw::1.0:None");
MODULE_INFO(linuxcnc, "param:stepgen.#.maxvel:float:3:rw::0:None");
MODULE_INFO(linuxcnc, "param:stepgen.step_polarity:bit:0:rw::None:None");
MODULE_INFO(linuxcnc, "param:stepgen.steplen:u32:0:rw:Step length in ns.:None:None");
MODULE_INFO(linuxcnc, "param:stepgen.stepspace:u32:0:rw:Step space in ns:None:None");
MODULE_INFO(linuxcnc, "param:stepgen.dirtime:u32:0:rw:Dir hold/setup in ns.  Refer to the pdf documentation for a diagram of what these timings mean.:None:None");
MODULE_INFO(linuxcnc, "pin:dout.##:bit:22:in:dout.\\fIMM\\fR corresponds to the pin labeled\nOUT\\fIM\\fR on the pinout diagram.:None:None");
MODULE_INFO(linuxcnc, "param:dout.##-invert:bit:22:rw:If TRUE, the output on the corresponding \\fBdout.\\fIMM\\fR is inverted.:None:None");
MODULE_INFO(linuxcnc, "pin:din.##:bit:16:out::None:None");
MODULE_INFO(linuxcnc, "pin:din.##_not:bit:16:out:din.\\fIMM\\fR corresponds to the pin labeled\nIN\\fIM\\fR on the pinout diagram.:None:None");
MODULE_INFO(linuxcnc, "param:communication_error:u32:0:rw:Incremented each time \npluto-step.read detects an error code in the EPP status register.  While\nthis register is nonzero, new values are not being written to the Pluto-P\nboard, and the status of digital outputs and the PWM duty cycle of the PWM\noutputs will remain unchanged.  If the hardware watchdog is enabled, it will\nactivate shortly after the communication error is detected by LinuxCNC.  To continue\nafter a communication error, set this parameter back to zero.:None:None");
MODULE_INFO(linuxcnc, "param:debug_0:s32:0:rw::None:None");
MODULE_INFO(linuxcnc, "param:debug_1:s32:0:rw::None:None");
MODULE_INFO(linuxcnc, "param:debug_2:float:0:rw::.5:None");
MODULE_INFO(linuxcnc, "param:debug_3:float:0:rw:Registers that hold debugging information of interest to developers:2.0:None");
MODULE_INFO(linuxcnc, "notes: One servo channel for i.e. spindle control.");
MODULE_INFO(linuxcnc, "notes:Encoder part");
MODULE_INFO(linuxcnc, "pin:encoder.#.count:s32:1:out::None:None");
MODULE_INFO(linuxcnc, "pin:encoder.#.position:float:1:out::None:None");
MODULE_INFO(linuxcnc, "pin:encoder.#.velocity:float:1:out::None:None");
MODULE_INFO(linuxcnc, "pin:encoder.#.reset:bit:1:in::None:None");
MODULE_INFO(linuxcnc, "pin:encoder.#.index-enable:bit:1:io::None:None");
MODULE_INFO(linuxcnc, "param:encoder.#.scale:float:1:rw::1.0:None");
MODULE_INFO(linuxcnc, "param:encoder.z-polarity:bit:0:rw:Set to TRUE if the index pulse is active low, FALSE if it is active high.  Affects all encoders.:None:None");
MODULE_INFO(linuxcnc, "notes:PWM part");
MODULE_INFO(linuxcnc, "pin:pwm.value:float:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:pwm.enable:bit:0:in:pwm.\\fIM\\fR corresponds to the pins labeled UP\\fIM\\fR and DN\\fIM\\fR on the pinout diagram:None:None");
MODULE_INFO(linuxcnc, "param:pwm.offset:float:0:rw::None:None");
MODULE_INFO(linuxcnc, "param:pwm.scale:float:0:rw::1.0:None");
MODULE_INFO(linuxcnc, "param:pwm.max-dc:float:0:rw::1.0:None");
MODULE_INFO(linuxcnc, "param:pwm.min-dc:float:0:rw::0:None");
MODULE_INFO(linuxcnc, "param:pwm.pwmdir:bit:0:rw:Set to TRUE use PWM+direction mode.  Set to FALSE to use Up/Down mode.:0:None");
MODULE_INFO(linuxcnc, "param:pwm.is-pdm:bit:0:rw:Set to TRUE to use PDM (also called interleaved PWM) mode.  Set to FALSE to use traditional PWM mode.  Affects all PWM outputs.:None:None");
MODULE_INFO(linuxcnc, "see_also:The \\fIpluto_step\\fR section in the HAL User Manual, which shows the location of each physical pin on the pluto board.");
MODULE_INFO(linuxcnc, "funct:transfer:1:transfers data between master and slave devices");
MODULE_INFO(linuxcnc, "funct:spitest:1:test spi transfer (only for developers)");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "author:Matsche");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_float_t *stepgen_position_cmd[3];
    hal_float_t *stepgen_velocity_fb[3];
    hal_float_t *stepgen_position_fb[3];
    hal_s32_t *stepgen_counts[3];
    hal_bit_t *stepgen_enable[3];
    hal_bit_t *stepgen_reset[3];
    hal_bit_t *dout[22];
    hal_bit_t *din[16];
    hal_bit_t *din_not[16];
    hal_s32_t *encoder_count[1];
    hal_float_t *encoder_position[1];
    hal_float_t *encoder_velocity[1];
    hal_bit_t *encoder_reset[1];
    hal_bit_t *encoder_index_enable[1];
    hal_float_t *pwm_value;
    hal_bit_t *pwm_enable;
    hal_float_t stepgen_scale[3];
    hal_float_t stepgen_maxvel[3];
    hal_bit_t stepgen_step_polarity;
    hal_u32_t stepgen_steplen;
    hal_u32_t stepgen_stepspace;
    hal_u32_t stepgen_dirtime;
    hal_bit_t dout_invert[22];
    hal_u32_t communication_error;
    hal_s32_t debug_0;
    hal_s32_t debug_1;
    hal_float_t debug_2;
    hal_float_t debug_3;
    hal_float_t encoder_scale[1];
    hal_bit_t encoder_z_polarity;
    hal_float_t pwm_offset;
    hal_float_t pwm_scale;
    hal_float_t pwm_max_dc;
    hal_float_t pwm_min_dc;
    hal_bit_t pwm_pwmdir;
    hal_bit_t pwm_is_pdm;
    void *_data;
};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void transfer(struct __comp_state *__comp_inst, long period);
static void spitest(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg);
static void extra_cleanup(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int j = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    inst->_data = (char*)inst + sizeof(struct __comp_state);
    r = extra_setup(inst, prefix, extra_arg);
    if(r != 0) return r;
    for(j=0; j < (3); j++) {
        r = hal_pin_float_newf(HAL_IN, &(inst->stepgen_position_cmd[j]), comp_id,
            "%s.stepgen.%01d.position-cmd", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (3); j++) {
        r = hal_pin_float_newf(HAL_OUT, &(inst->stepgen_velocity_fb[j]), comp_id,
            "%s.stepgen.%01d.velocity-fb", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (3); j++) {
        r = hal_pin_float_newf(HAL_OUT, &(inst->stepgen_position_fb[j]), comp_id,
            "%s.stepgen.%01d.position-fb", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (3); j++) {
        r = hal_pin_s32_newf(HAL_OUT, &(inst->stepgen_counts[j]), comp_id,
            "%s.stepgen.%01d.counts", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (3); j++) {
        r = hal_pin_bit_newf(HAL_IN, &(inst->stepgen_enable[j]), comp_id,
            "%s.stepgen.%01d.enable", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (3); j++) {
        r = hal_pin_bit_newf(HAL_IN, &(inst->stepgen_reset[j]), comp_id,
            "%s.stepgen.%01d.reset", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (22); j++) {
        r = hal_pin_bit_newf(HAL_IN, &(inst->dout[j]), comp_id,
            "%s.dout.%02d", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (16); j++) {
        r = hal_pin_bit_newf(HAL_OUT, &(inst->din[j]), comp_id,
            "%s.din.%02d", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (16); j++) {
        r = hal_pin_bit_newf(HAL_OUT, &(inst->din_not[j]), comp_id,
            "%s.din.%02d-not", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (1); j++) {
        r = hal_pin_s32_newf(HAL_OUT, &(inst->encoder_count[j]), comp_id,
            "%s.encoder.%01d.count", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (1); j++) {
        r = hal_pin_float_newf(HAL_OUT, &(inst->encoder_position[j]), comp_id,
            "%s.encoder.%01d.position", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (1); j++) {
        r = hal_pin_float_newf(HAL_OUT, &(inst->encoder_velocity[j]), comp_id,
            "%s.encoder.%01d.velocity", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (1); j++) {
        r = hal_pin_bit_newf(HAL_IN, &(inst->encoder_reset[j]), comp_id,
            "%s.encoder.%01d.reset", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (1); j++) {
        r = hal_pin_bit_newf(HAL_IO, &(inst->encoder_index_enable[j]), comp_id,
            "%s.encoder.%01d.index-enable", prefix, j);
        if(r != 0) return r;
    }
    r = hal_pin_float_newf(HAL_IN, &(inst->pwm_value), comp_id,
        "%s.pwm.value", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->pwm_enable), comp_id,
        "%s.pwm.enable", prefix);
    if(r != 0) return r;
    for(j=0; j < (3); j++) {
        r = hal_param_float_newf(HAL_RW, &(inst->stepgen_scale[j]), comp_id,
            "%s.stepgen.%01d.scale", prefix, j);
        if(r != 0) return r;
    inst->stepgen_scale[j] = 1.0;
    }
    for(j=0; j < (3); j++) {
        r = hal_param_float_newf(HAL_RW, &(inst->stepgen_maxvel[j]), comp_id,
            "%s.stepgen.%01d.maxvel", prefix, j);
        if(r != 0) return r;
    inst->stepgen_maxvel[j] = 0;
    }
    r = hal_param_bit_newf(HAL_RW, &(inst->stepgen_step_polarity), comp_id,
        "%s.stepgen.step-polarity", prefix);
    if(r != 0) return r;
    r = hal_param_u32_newf(HAL_RW, &(inst->stepgen_steplen), comp_id,
        "%s.stepgen.steplen", prefix);
    if(r != 0) return r;
    r = hal_param_u32_newf(HAL_RW, &(inst->stepgen_stepspace), comp_id,
        "%s.stepgen.stepspace", prefix);
    if(r != 0) return r;
    r = hal_param_u32_newf(HAL_RW, &(inst->stepgen_dirtime), comp_id,
        "%s.stepgen.dirtime", prefix);
    if(r != 0) return r;
    for(j=0; j < (22); j++) {
        r = hal_param_bit_newf(HAL_RW, &(inst->dout_invert[j]), comp_id,
            "%s.dout.%02d-invert", prefix, j);
        if(r != 0) return r;
    }
    r = hal_param_u32_newf(HAL_RW, &(inst->communication_error), comp_id,
        "%s.communication-error", prefix);
    if(r != 0) return r;
    r = hal_param_s32_newf(HAL_RW, &(inst->debug_0), comp_id,
        "%s.debug-0", prefix);
    if(r != 0) return r;
    r = hal_param_s32_newf(HAL_RW, &(inst->debug_1), comp_id,
        "%s.debug-1", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->debug_2), comp_id,
        "%s.debug-2", prefix);
    inst->debug_2 = .5;
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->debug_3), comp_id,
        "%s.debug-3", prefix);
    inst->debug_3 = 2.0;
    if(r != 0) return r;
    for(j=0; j < (1); j++) {
        r = hal_param_float_newf(HAL_RW, &(inst->encoder_scale[j]), comp_id,
            "%s.encoder.%01d.scale", prefix, j);
        if(r != 0) return r;
    inst->encoder_scale[j] = 1.0;
    }
    r = hal_param_bit_newf(HAL_RW, &(inst->encoder_z_polarity), comp_id,
        "%s.encoder.z-polarity", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->pwm_offset), comp_id,
        "%s.pwm.offset", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->pwm_scale), comp_id,
        "%s.pwm.scale", prefix);
    inst->pwm_scale = 1.0;
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->pwm_max_dc), comp_id,
        "%s.pwm.max-dc", prefix);
    inst->pwm_max_dc = 1.0;
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->pwm_min_dc), comp_id,
        "%s.pwm.min-dc", prefix);
    inst->pwm_min_dc = 0;
    if(r != 0) return r;
    r = hal_param_bit_newf(HAL_RW, &(inst->pwm_pwmdir), comp_id,
        "%s.pwm.pwmdir", prefix);
    inst->pwm_pwmdir = 0;
    if(r != 0) return r;
    r = hal_param_bit_newf(HAL_RW, &(inst->pwm_is_pdm), comp_id,
        "%s.pwm.is-pdm", prefix);
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s.transfer", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))transfer, inst, 1, 0, comp_id);
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s.spitest", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))spitest, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
int rtapi_app_main(void) {
    int r = 0;
    comp_id = hal_init("pluto_mix_rpspi");
    if(comp_id < 0) return comp_id;
    r = export("pluto-mix-rpspi", 0);
    if(r) {
    extra_cleanup();
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    extra_cleanup();
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef stepgen_position_cmd
#define stepgen_position_cmd(i) (0+*(__comp_inst->stepgen_position_cmd[i]))
#undef stepgen_velocity_fb
#define stepgen_velocity_fb(i) (*(__comp_inst->stepgen_velocity_fb[i]))
#undef stepgen_position_fb
#define stepgen_position_fb(i) (*(__comp_inst->stepgen_position_fb[i]))
#undef stepgen_counts
#define stepgen_counts(i) (*(__comp_inst->stepgen_counts[i]))
#undef stepgen_enable
#define stepgen_enable(i) (0+*(__comp_inst->stepgen_enable[i]))
#undef stepgen_reset
#define stepgen_reset(i) (0+*(__comp_inst->stepgen_reset[i]))
#undef dout
#define dout(i) (0+*(__comp_inst->dout[i]))
#undef din
#define din(i) (*(__comp_inst->din[i]))
#undef din_not
#define din_not(i) (*(__comp_inst->din_not[i]))
#undef encoder_count
#define encoder_count(i) (*(__comp_inst->encoder_count[i]))
#undef encoder_position
#define encoder_position(i) (*(__comp_inst->encoder_position[i]))
#undef encoder_velocity
#define encoder_velocity(i) (*(__comp_inst->encoder_velocity[i]))
#undef encoder_reset
#define encoder_reset(i) (0+*(__comp_inst->encoder_reset[i]))
#undef encoder_index_enable
#define encoder_index_enable(i) (*(__comp_inst->encoder_index_enable[i]))
#undef pwm_value
#define pwm_value (0+*__comp_inst->pwm_value)
#undef pwm_enable
#define pwm_enable (0+*__comp_inst->pwm_enable)
#undef stepgen_scale
#define stepgen_scale(i) (__comp_inst->stepgen_scale[i])
#undef stepgen_maxvel
#define stepgen_maxvel(i) (__comp_inst->stepgen_maxvel[i])
#undef stepgen_step_polarity
#define stepgen_step_polarity (__comp_inst->stepgen_step_polarity)
#undef stepgen_steplen
#define stepgen_steplen (__comp_inst->stepgen_steplen)
#undef stepgen_stepspace
#define stepgen_stepspace (__comp_inst->stepgen_stepspace)
#undef stepgen_dirtime
#define stepgen_dirtime (__comp_inst->stepgen_dirtime)
#undef dout_invert
#define dout_invert(i) (__comp_inst->dout_invert[i])
#undef communication_error
#define communication_error (__comp_inst->communication_error)
#undef debug_0
#define debug_0 (__comp_inst->debug_0)
#undef debug_1
#define debug_1 (__comp_inst->debug_1)
#undef debug_2
#define debug_2 (__comp_inst->debug_2)
#undef debug_3
#define debug_3 (__comp_inst->debug_3)
#undef encoder_scale
#define encoder_scale(i) (__comp_inst->encoder_scale[i])
#undef encoder_z_polarity
#define encoder_z_polarity (__comp_inst->encoder_z_polarity)
#undef pwm_offset
#define pwm_offset (__comp_inst->pwm_offset)
#undef pwm_scale
#define pwm_scale (__comp_inst->pwm_scale)
#undef pwm_max_dc
#define pwm_max_dc (__comp_inst->pwm_max_dc)
#undef pwm_min_dc
#define pwm_min_dc (__comp_inst->pwm_min_dc)
#undef pwm_pwmdir
#define pwm_pwmdir (__comp_inst->pwm_pwmdir)
#undef pwm_is_pdm
#define pwm_is_pdm (__comp_inst->pwm_is_pdm)
#undef data
#define data (*(internal*)(__comp_inst->_data))


#line 138 "pluto_mix_rpspi.comp"

#include "rtapi.h"
#include "rtapi_bitops.h"
#include "rtapi_app.h"
#include "hal.h"

#define BUILD_SYS_USER_DSO
#define TARGET_PLATFORM_RASPBERRY

#define u32 unsigned int 
#define __u32 unsigned int
#define u16 unsigned short
#define __u16 unsigned short

#if !defined(BUILD_SYS_USER_DSO)
#error "This driver is for usermode threads only"
#endif

#if !defined(TARGET_PLATFORM_RASPBERRY)
#error "This driver is for the Raspberry Pi platform only"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>
#include <stdarg.h>

#include "pluto_common_rpspi.h"

volatile unsigned *gpio, *spi;
static volatile u32 txBuf[BUFSIZE], rxBuf[BUFSIZE];
static platform_t platform;

static int map_gpio();
static void setup_gpio();
static void restore_gpio();
static int pluto_program(char *);
platform_t check_platform(void);

static int speedrange=0;
RTAPI_MP_INT(speedrange, "Speed range 0..3");

#define PLUTO_SPEED_NS (1600)
#define PLUTO_SPEED    (PLUTO_SPEED_NS * 1e-9)
#define PLUTO_FREQ     (1e9 / PLUTO_SPEED_NS)
#define TMAX           ((1<<5)-1)

#define W 10
#define F 11
#define MODULO ((1<<(W+F))-1)
#define MASK ((1<<(W+F))-1)
#define MAXDELTA (MASK/2)

// Encoder
#define QW 14
#define QMASK ((1<<QW)-1)

typedef struct {
	int64_t last_index[4];
	int64_t last_count[4];
	int64_t reset_count[4];
	double old_position_cmd[4];
	double old_velocity_cmd[4];
} internal;

#define ONE (1<<F)
#define MAX_STEP_RATE ((1<<F)-1)

int PWM(int enable, double value, double offset, double scale, double min_dc, double max_dc, int dio0, int dio1, int is_pdm, int is_pwmdir) {
    int result;
    if(enable == 0) return 0;

    value = value / scale + offset;
    if(value < -max_dc) value = -max_dc;
    else if(value > -min_dc && value < 0) value = -min_dc;
    else if(value > 0 && value < min_dc) value = min_dc;
    else if(value > max_dc) value = max_dc;

    value = 2047 * value;
    if(value < -2047) value = -2047;
    if(value > 2047) value = 2047;

    if(value < 0) {
	    if(is_pwmdir) {
            result = (1<<13) | (int)(-value);
	    } else {
            result = (1<<15) | (int)(-value);
	    }
    } else result = value;
    if(is_pdm) result |= 1<<14;
    if(dio0) result ^= 1<<12;
    if(dio1) result ^= 1<<13;

    return result;
}


EXTRA_SETUP() {
	int i, retval = 0;

	platform = check_platform();
	retval = map_gpio();
	if (retval < 0) {
		rtapi_print_msg(RTAPI_MSG_ERR,
		        "HAL_pluto_servo_rpspi: ERROR: cannot map GPIO memory\n");
		return retval;
	}
	
	if(firmware != "")
	{
		retval = pluto_program(firmware);
		if(retval < 0)
		{
			rtapi_print_msg(RTAPI_MSG_ERR,
					"HAL_pluto_servo_rpspi: ERROR: uploading firmware failed!!!\n");
			return retval;
		}
	}
        
	setup_gpio();

	return 0;
}

EXTRA_CLEANUP() {
	// reset the FPGA
	GPIO_CLR = 1<<25;
	usleep(1000);
	GPIO_SET = 1<<25;
	usleep(1000);

	if (gpio != MAP_FAILED && spi != MAP_FAILED) {
		
		restore_gpio();
		munmap((void *)gpio,BLOCK_SIZE);
		munmap((void *)spi,BLOCK_SIZE);
	}
}

FUNCTION(spitest) {
	char *buf;
	int i;
	__u32 spidata;
	
	for (i=0; i<BUFSIZE; i++) {
		txBuf[i] = i;
	}
	
	/* activate transfer */
	BCM2835_SPICS = SPI_CS_TA|SPI_CS_CPHA;

	/* send txBuf */
	/* RPi SPI transfers 8 bits at a time only */
	buf = (char *)txBuf;
	for (i=0; i<SPIBUFSIZE; i++) {
		BCM2835_SPIFIFO = *buf++;
	}

	/* wait until transfer is finished */
	while (!(BCM2835_SPICS & SPI_CS_DONE));

	/* clear DONE bit */
	BCM2835_SPICS = SPI_CS_DONE;

	/*****************************************************************************/
	/* read buffer */
	/* RPi SPI transfers 8 bits at a time only */
	buf = (char *)rxBuf;
	for (i=0; i<SPIBUFSIZE; i++) {
		*buf++ = BCM2835_SPIFIFO;
	}
	
	for (i=5; i<BUFSIZE; i++) {
		spidata = rxBuf[i];
	}
}
	
FUNCTION(transfer) {
	char *buf;
	__u16 * tbuf;
	
	int i;
	__u32 spidata;
	
	int r = 0;
	int stepspace_ticks = stepgen_stepspace/PLUTO_SPEED_NS;
	int steplen_ticks = stepgen_steplen/PLUTO_SPEED_NS;
	int dirtime_ticks = stepgen_dirtime/PLUTO_SPEED_NS;
	int rate, maxrate = MAX_STEP_RATE;
	double fmax;

	if(steplen_ticks > TMAX) {
		steplen_ticks = TMAX;
		rtapi_print_msg(RTAPI_MSG_ERR,
				"Requested step length %dns decreased to %dns "
				"due to hardware limitations\n",
				stepgen_steplen, TMAX * PLUTO_SPEED_NS);
		stepgen_steplen = TMAX * PLUTO_SPEED_NS;
	}

	if(dirtime_ticks > TMAX) {
		dirtime_ticks = TMAX;
		rtapi_print_msg(RTAPI_MSG_ERR,
				"Requested direction change time %dns decreased to %dns "
				"due to hardware limitations\n",
				stepgen_dirtime, TMAX * PLUTO_SPEED_NS);
		stepgen_dirtime = TMAX * PLUTO_SPEED_NS;
	}

	// Speed limits come from several sources
	// First limit: step waveform timings
	fmax = 1.0 / PLUTO_SPEED / (2 + steplen_ticks + stepspace_ticks);
	// Second limit: highest speed command
	if(fmax > PLUTO_FREQ / (2<<speedrange))
			fmax = PLUTO_SPEED * (2<<speedrange);
	// Third limit: max sign-extenable counts per period
	if(fmax > MAXDELTA / fperiod / (1<<speedrange))
			fmax = MAXDELTA / fperiod / (1<<speedrange);

	//if(communication_error) return;
	
	//------------------------------
	// Stepper channel begin
	tbuf = (__u16 *)txBuf;
	for(i=0; i<3; i++) {
		double new_position_cmd = stepgen_position_cmd(i);
		double v = new_position_cmd - data.old_position_cmd[i];
		double est_err = stepgen_position_fb(i) + data.old_velocity_cmd[i] * fperiod - new_position_cmd;
		double actual_max;
		double scale_abs = abs(stepgen_scale(i));

		v = v - 0.5 * est_err / fperiod;
		if(v > 0) v = v + .5/scale_abs;
		else if(v < 0) v = v - .5/scale_abs;

		data.old_position_cmd[i] = new_position_cmd;
		data.old_velocity_cmd[i] = v;
		actual_max = fmax / scale_abs;
		if(stepgen_maxvel(i) < 0) stepgen_maxvel(i) = -stepgen_maxvel(i);
		if(stepgen_maxvel(i) != 0 && stepgen_maxvel(i) > actual_max) {
			static int message_printed[4] = {0,0,0,0};
			if(!message_printed[i]) {
				rtapi_print_msg(RTAPI_MSG_ERR,
						"Requested step rate %dHz decreased to %dHz "
						"due to hardware or timing limitations\n",
						(int)(stepgen_maxvel(i) * scale_abs),
						(int)(fmax));
				message_printed[i] = 1;
			}
			stepgen_maxvel(i) = actual_max;
		}

		if(stepgen_maxvel(i) == 0) {
			if(v < -actual_max) v = -actual_max;
			if(v > actual_max) v = actual_max;
		}else {
			if(v < -stepgen_maxvel(i)) v = -stepgen_maxvel(i);
			if(v > stepgen_maxvel(i)) v = stepgen_maxvel(i);
		}
		rate = v*stepgen_scale(i)*ONE*PLUTO_SPEED/(1<<speedrange);

		if(rate > maxrate) rate = maxrate;
		if(rate < -maxrate) rate = -maxrate;

		if(!stepgen_enable(i)) rate = 0;
		//if(i == 0) debug_1 = rate;
		//if(!i%2)
		//	txBuf[i%2] = 0;
		//txBuf[i%2] |= rate<<(16*(i%2));
		tbuf[i] = rate;
	}
	// Stepper channel end
	//------------------------------

	//------------------------------
	// Servo channel begin
	if(pwm_max_dc > 1) pwm_max_dc = 1;
	else if(pwm_max_dc < 0) pwm_max_dc = 0;
	if(pwm_min_dc < 0) pwm_min_dc = 0;
	else if(pwm_min_dc > pwm_max_dc) pwm_min_dc = pwm_max_dc;
	
#define D(x) (!dout(x) ^ !dout_invert(x))
	tbuf[3] = PWM(pwm_enable, pwm_value, pwm_offset, pwm_scale, 
			pwm_min_dc, pwm_max_dc, D(20), D(21), pwm_is_pdm, pwm_pwmdir);
	// Servo channel end		txBuf[1] is now full ;)
	//------------------------------
	
	r = 0;
	for(i=0; i<14; i++) {
		if(!dout(i) ^ !dout_invert(i)) r |= (1<<i);
	}
	//txBuf[2] = r;
	
	r  |= (steplen_ticks | (dirtime_ticks << 8)) <<16;
	//r = steplen_ticks+stepspace_ticks | (dirtime_ticks << 8);
	if (stepgen_step_polarity) {
			r |= 0x80000000;
	}else r &= 0x7FFFFFFF;
	txBuf[2] = r;
	
	for (i=3; i<BUFSIZE; i++) {
		txBuf[i] = i;
	}
	if (encoder_z_polarity) 
	{
		txBuf[3] |= 1<<31;
	}else txBuf[3] &= 0x7FFFFFFF;
	
	/* activate transfer */
	BCM2835_SPICS = SPI_CS_TA|SPI_CS_CPHA|SPI_CS_CPOL;

	/* send txBuf */
	/* RPi SPI transfers 8 bits at a time only */
	buf = (char *)txBuf;
	for (i=0; i<SPIBUFSIZE; i++) {
		BCM2835_SPIFIFO = *buf++;
	}

	/* wait until transfer is finished */
	while (!(BCM2835_SPICS & SPI_CS_DONE));

	/* clear DONE bit */
	BCM2835_SPICS = SPI_CS_DONE|SPI_CS_CPHA|SPI_CS_CPOL;

	/*****************************************************************************/
	/* read buffer */
	/* RPi SPI transfers 8 bits at a time only */
	buf = (char *)rxBuf;
	for (i=0; i<SPIBUFSIZE; i++) {
		*buf++ = BCM2835_SPIFIFO;
	}
	
	for(i=0; i<3; i++) {
		int64_t count;
		double fcount;
		int newlow;
		int reset;
		
		spidata = rxBuf[i];
		
		reset = stepgen_reset(i);
		newlow = spidata & MASK;
		count = extend(data.last_count[i], newlow, W+F);
		stepgen_velocity_fb(i) = (count-data.last_count[i])/stepgen_scale(i)/fperiod/(1<<F);
		data.last_count[i] = count;
		if(reset) data.reset_count[i] = count;
		fcount = (count-data.reset_count[i])*1.0/(1<<F);
		stepgen_counts(i) = fcount;
		stepgen_position_fb(i) = fcount/stepgen_scale(i);


		//if(i == 0) {
		if(0) {
			//debug_0 = count;
			//debug_1 = newlow;
			debug_2 = fcount;
			debug_3 = stepgen_position_fb(i);
		}
	}
	
	//------------------------------
	// Get encoder begin
	for(i=0; i<1; i++) {
		int64_t count, index;
		int newlow, indlow, indexed;
		int reset;
		
		spidata = rxBuf[i+3];
		reset = encoder_reset(i);

		newlow = spidata & QMASK;
		indlow = (spidata >> QW) & QMASK;
		indexed = spidata & (1<<(2*QW));

		count = extend(data.last_count[i+3], newlow, QW);
		if(indexed)
				index = extend(count, indlow, QW);
		else
				index = data.last_index[i+3];

		if(encoder_index_enable(i) && indexed) {
				encoder_index_enable(i) = 0;
				data.reset_count[i+3] = index;
		}
		if(reset) encoder_velocity(i) = 0;
		else encoder_velocity(i) = (count - data.last_count[i+3]) /
				encoder_scale(i) / fperiod;
		data.last_index[i+3] = index;
		data.last_count[i+3] = count;
		if(reset) data.reset_count[i+3] = count;
		encoder_count(i) = count - data.reset_count[i+3];
		encoder_position(i) = encoder_count(i) / encoder_scale(i);
	}
	// Get encoder end
	//------------------------------
	
	spidata = rxBuf[4];
	//debug_0 = spidata; //din
	//debug_1 = spidata;

	for(i=0; i<16; i++) {
		int b = spidata & (1<<i);
		din(i) = !!b;
		din_not(i) = !b;
	}
	
	for (i=5; i<BUFSIZE; i++) {
		spidata = rxBuf[i];
	}
	
}

int map_gpio() {
	int fd;
	static u32 mem_base, mem_spi_base;

	switch (platform) {
	case RPI:
		mem_base = BCM2835_GPIO_BASE;
		mem_spi_base = BCM2835_SPI_BASE;
		break;
	case RPI_2:
		mem_base = BCM2835_GPIO_BASE + BCM2709_OFFSET;
		mem_spi_base = BCM2835_SPI_BASE + BCM2709_OFFSET;
		break;
	}

	fd = rtapi_open_as_root("/dev/mem", O_RDWR | O_SYNC);
	if (fd < 0) {
		rtapi_print_msg(RTAPI_MSG_ERR,"HAL_pluto_servo_rpspi: can't open /dev/mem \n");
		return -1;
	}

	/* mmap GPIO */
	gpio = mmap(
	        NULL,
	        BLOCK_SIZE,
	        PROT_READ|PROT_WRITE,
	        MAP_SHARED,
	        fd,
	        mem_base);

	/* mmap SPI */
	spi = mmap(
	        NULL,
	        BLOCK_SIZE,
	        PROT_READ|PROT_WRITE,
	        MAP_SHARED,
	        fd,
	        mem_spi_base);

	close(fd);

	if (gpio == MAP_FAILED) {
		rtapi_print_msg(RTAPI_MSG_ERR,"HAL_pluto_servo_rpspi: can't map gpio\n");
		return -2;
	}

	if (spi == MAP_FAILED) {
		rtapi_print_msg(RTAPI_MSG_ERR,"HAL_pluto_servo_rpspi: can't map spi\n");
		return -3;
	}

	return 0;
}

void setup_gpio() {
	uint32_t x;

	/* change SPI pins */
	x = BCM2835_GPFSEL0;
	//x &= ~(0b111 << (7*3) | 0b111 << (8*3) | 0b111 << (9*3));
	//x |= (0b001 << (7*3) | 0b100 << (8*3) | 0b100 << (9*3));	// GPIO pin7 output, pin8 pin9 alternate0 (SPI)
	x &= ~(0b111 << (8*3) | 0b111 << (9*3));
	x |= (0b100 << (8*3) | 0b100 << (9*3));	// pin8 pin9 alternate0 (SPI)
	BCM2835_GPFSEL0 = x;

	x = BCM2835_GPFSEL1;
	x &= ~(0b111 << (0*3) | 0b111 << (1*3));
	x |= (0b100 << (0*3) | 0b100 << (1*3));	// pin10 pin11 alternate0 (SPI)
	BCM2835_GPFSEL1 = x;

	/* set up SPI */
	BCM2835_SPICLK = 400;

	BCM2835_SPICS = 0;

	/* clear FIFOs */
	BCM2835_SPICS |= SPI_CS_CLEAR_RX | SPI_CS_CLEAR_TX;

	/* clear done bit */
	BCM2835_SPICS |= SPI_CS_DONE;
}

void restore_gpio() {
	uint32_t x;

	/* change SPI pins to inputs*/
	x = BCM2835_GPFSEL0;
	//x &= ~(0b111 << (7*3) | 0b111 << (8*3) | 0b111 << (9*3));
	x &= ~(0b111 << (8*3) | 0b111 << (9*3));
	BCM2835_GPFSEL0 = x;

	x = BCM2835_GPFSEL1;
	x &= ~(0b111 << (0*3) | 0b111 << (1*3));
	BCM2835_GPFSEL1 = x;
}

#define FIRMWARE_SIZE 19895
static int pluto_program(char *firmware) {
	int byte, bit;
	int i;
	FILE *f;
	int size = 0;
	
	//f= fopen("/home/mk/src/spi-fpga-driver/pluto_mix_firmware/pluto_spi_mix_31.rbf", "rb");
	f= fopen(firmware, "rb");
	if(!f) {
		rtapi_print_msg(RTAPI_MSG_ERR, "fopen-Error\n");
		return -EIO;
	}
	if(fseek(f, 0, SEEK_END))
	{
		rtapi_print_msg(RTAPI_MSG_ERR, "fseek-Error!\n");
		return -EIO;
	}
	size = ftell(f);
	rewind(f);
	rtapi_print_msg(RTAPI_MSG_INFO, "Filesize: %d Bytes\n", size);
	if(size != FIRMWARE_SIZE)
	{
		rtapi_print_msg(RTAPI_MSG_ERR, "Incorrect filesize!!\n");
		return -EIO;
	}
	unsigned char buf[size];
	if(fread(buf, 1, size, f) != FIRMWARE_SIZE) {
		rtapi_print_msg(RTAPI_MSG_ERR,"fread-Error!\n");
		return -EIO;
	}
	
	/***************************/
	/** Just a extra tuition	**/ 
	uint32_t x;
	/* setup GPIO 25 as OUTPUT connected to Data2 on Pluto (internal nRESET) */
	x = BCM2835_GPFSEL2;		// (25/10)
	x &= ~(0b111 << (5*3));	// (25%10*3)
	x |= (0b001 << (5*3));	// pin25 OUTPUT
	BCM2835_GPFSEL2 = x;
	
	/* setup GPIO 24 as INPUT connected to nPaperOut on Pluto */
	x = BCM2835_GPFSEL2;		// (24/10)
	x &= ~(0b111 << (4*3));	// (24%10*3) pin24 INPUT
	BCM2835_GPFSEL2 = x;
	/***************************/
	
	// Set GPIO pins 8-11 to output for Pluto Programming (CE0, MISO, MOSI, SCKL)
	for (i=8; i<=11; i++)
	{
		INP_GPIO(i); // must use INP_GPIO before we can use OUT_GPIO
		OUT_GPIO(i);
	}
	
	
	// reset the FPGA in advance
	GPIO_CLR = 1<<25;
	usleep(1000);
	GPIO_SET = 1<<25;
	usleep(1000);
	
		rtapi_print_msg(RTAPI_MSG_ERR,"uploading pluto-spi-firmware...\n");

	// pull the reset low -- bit 2 of Control register
	// keep it low 2 microseconds
	for(i=0; i<12; i++) GPIO_CLR = 1<<8;	//outb(0, ioaddr+2);

	// let it go high again
	// delay 10 microseconds to guarantee nStatus high
	for(i=0; i<40; i++) GPIO_SET = 1<<8;	//outb(4, ioaddr+2);

	// Now program the device...
	for(byte = 0; byte < FIRMWARE_SIZE; byte++) {
		for(bit = 0; bit < 8; bit++) {
			int v = buf[byte] & (1<<bit);
			if(v) GPIO_SET = 1<<10; else GPIO_CLR = 1<<10;
			for(i=0; i<22; i++) GPIO_CLR = 1<<11;		//outb(0|4, ioaddr+2);
			
			for(i=0; i<22; i++) GPIO_SET = 1<<11;		//outb(1|4, ioaddr+2);
			
				for(i=0; i<22; i++) GPIO_CLR = 1<<11;
		}
	}
	rtapi_print_msg(RTAPI_MSG_ERR,"...done\n");
}

platform_t check_platform(void)
{
	FILE *fp;
	char buf[2048];
	size_t fsize;

	fp = fopen("/proc/cpuinfo", "r");
	fsize = fread(buf, 1, sizeof(buf), fp);
	fclose(fp);
	
	if (fsize == 0 || fsize == sizeof(buf))
		return 0;

	/* NUL terminate the buffer */
	buf[fsize] = '\0';

	if (NULL != strstr(buf, "BCM2708"))
		return RPI;
	else if (NULL != strstr(buf, "BCM2709"))
		return RPI_2;
	else if (NULL != strstr(buf, "BCM2835"))
                return RPI_2;
	else
		return UNSUPPORTED;
}

static int __comp_get_data_size(void) { return sizeof(internal); }
