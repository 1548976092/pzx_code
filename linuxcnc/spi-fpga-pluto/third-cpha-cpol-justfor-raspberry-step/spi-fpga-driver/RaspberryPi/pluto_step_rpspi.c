/* Autogenerated by /usr/bin/halcompile on Sat Oct 26 13:32:25 2019 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:pluto_step_rpspi:Hardware driver and firmware for the Pluto-P parallel-port FPGA, for use with stepper machines.and RaspberryPi SPI .");
MODULE_INFO(linuxcnc, "descr:\n\nPluto_step is a LinuxCNC software driver and associated firmware that allow the Pluto-P board to be used to control a stepper-based CNC machine.\n\n\n\nThe driver has 4 step+direction channels, 14 dedicated digital outputs, and 16\n\ndedicated digital inputs.\n\n\n\n.SS Step generators\n\nThe step generator takes a position input and output.\n\n\n\nThe step waveform includes step length/space and direction hold/setup time.\n\nStep length and direction setup/hold time is enforced in the FPGA.  Step space\n\nis enforced by a velocity cap in the driver.\n\n\n\n\\fI(all the following numbers are subject to change)\\fR\n\nIn \\fIspeedrange=0\\fR, the maximum step rate is 312.5kHz.  For position\n\nfeedback to be accurate, the maximum step rate is 512 pulses per servo cycle\n\n(so a 1kHz servo cycle does not impose any additional limitation).  The maximum\n\nstep rate may be lowered by the step length and space parameters, which are\n\nrounded up to the nearest multiple of 1600ns.\n\n\n\nIn successive speedranges the maximum step rate is divided in half, as is the\n\nmaximum steps per servo cycle, and the minimum nonzero step rate.\n\n\n\n.SS Digital I/O\n\nThe digital output pins conform to the `canonical digital output' interface\n\ndescribed in the HAL manual.\n\n\n\nThe digital input pins conform to the `canonical digital input' interface\n\ndescribed in the HAL manual.\n\n");
MODULE_INFO(linuxcnc, "pin:stepgen.#.position-cmd:float:4:in::None:None");
MODULE_INFO(linuxcnc, "pin:stepgen.#.velocity-fb:float:4:out::None:None");
MODULE_INFO(linuxcnc, "pin:stepgen.#.position-fb:float:4:out::None:None");
MODULE_INFO(linuxcnc, "pin:stepgen.#.counts:s32:4:out::None:None");
MODULE_INFO(linuxcnc, "pin:stepgen.#.enable:bit:4:in::None:None");
MODULE_INFO(linuxcnc, "pin:stepgen.#.reset:bit:4:in:When TRUE, reset position-fb to 0:None:None");
MODULE_INFO(linuxcnc, "param:stepgen.#.scale:float:4:rw::1.0:None");
MODULE_INFO(linuxcnc, "param:stepgen.#.maxvel:float:4:rw::0:None");
MODULE_INFO(linuxcnc, "param:stepgen.step_polarity:bit:0:rw::None:None");
MODULE_INFO(linuxcnc, "param:stepgen.steplen:u32:0:rw:Step length in ns.:None:None");
MODULE_INFO(linuxcnc, "param:stepgen.stepspace:u32:0:rw:Step space in ns:None:None");
MODULE_INFO(linuxcnc, "param:stepgen.dirtime:u32:0:rw:Dir hold/setup in ns.  Refer to the pdf documentation for a diagram of what these timings mean.:None:None");
MODULE_INFO(linuxcnc, "pin:dout.##:bit:14:in:dout.\\fIMM\\fR corresponds to the pin labeled\n\nOUT\\fIM\\fR on the pinout diagram.:None:None");
MODULE_INFO(linuxcnc, "param:dout.##-invert:bit:14:rw:If TRUE, the output on the corresponding \\fBdout.\\fIMM\\fR is inverted.:None:None");
MODULE_INFO(linuxcnc, "pin:din.##:bit:16:out::None:None");
MODULE_INFO(linuxcnc, "pin:din.##_not:bit:16:out:din.\\fIMM\\fR corresponds to the pin labeled\n\nIN\\fIM\\fR on the pinout diagram.:None:None");
MODULE_INFO(linuxcnc, "param:communication_error:u32:0:rw:Incremented each time \n\npluto-step.read detects an error code in the EPP status register.  While\n\nthis register is nonzero, new values are not being written to the Pluto-P\n\nboard, and the status of digital outputs and the PWM duty cycle of the PWM\n\noutputs will remain unchanged.  If the hardware watchdog is enabled, it will\n\nactivate shortly after the communication error is detected by LinuxCNC.  To continue\n\nafter a communication error, set this parameter back to zero.:None:None");
MODULE_INFO(linuxcnc, "param:debug_0:s32:0:rw::None:None");
MODULE_INFO(linuxcnc, "param:debug_1:s32:0:rw::None:None");
MODULE_INFO(linuxcnc, "param:debug_2:float:0:rw::.5:None");
MODULE_INFO(linuxcnc, "param:debug_3:float:0:rw:Registers that hold debugging information of interest to developers:2.0:None");
MODULE_INFO(linuxcnc, "see_also:The \\fIpluto_step\\fR section in the HAL User Manual, which shows the location of each physical pin on the pluto board.");
MODULE_INFO(linuxcnc, "funct:transfer:1:transfers data between master and slave devices");
MODULE_INFO(linuxcnc, "funct:spitest:1:test spi transfer (only for developers)");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "author:Matsche");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_float_t *stepgen_position_cmd[4];
    hal_float_t *stepgen_velocity_fb[4];
    hal_float_t *stepgen_position_fb[4];
    hal_s32_t *stepgen_counts[4];
    hal_bit_t *stepgen_enable[4];
    hal_bit_t *stepgen_reset[4];
    hal_bit_t *dout[14];
    hal_bit_t *din[16];
    hal_bit_t *din_not[16];
    hal_float_t stepgen_scale[4];
    hal_float_t stepgen_maxvel[4];
    hal_bit_t stepgen_step_polarity;
    hal_u32_t stepgen_steplen;
    hal_u32_t stepgen_stepspace;
    hal_u32_t stepgen_dirtime;
    hal_bit_t dout_invert[14];
    hal_u32_t communication_error;
    hal_s32_t debug_0;
    hal_s32_t debug_1;
    hal_float_t debug_2;
    hal_float_t debug_3;
    void *_data;
};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void transfer(struct __comp_state *__comp_inst, long period);
static void spitest(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg);
static void extra_cleanup(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int j = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    inst->_data = (char*)inst + sizeof(struct __comp_state);
    r = extra_setup(inst, prefix, extra_arg);
    if(r != 0) return r;
    for(j=0; j < (4); j++) {
        r = hal_pin_float_newf(HAL_IN, &(inst->stepgen_position_cmd[j]), comp_id,
            "%s.stepgen.%01d.position-cmd", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (4); j++) {
        r = hal_pin_float_newf(HAL_OUT, &(inst->stepgen_velocity_fb[j]), comp_id,
            "%s.stepgen.%01d.velocity-fb", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (4); j++) {
        r = hal_pin_float_newf(HAL_OUT, &(inst->stepgen_position_fb[j]), comp_id,
            "%s.stepgen.%01d.position-fb", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (4); j++) {
        r = hal_pin_s32_newf(HAL_OUT, &(inst->stepgen_counts[j]), comp_id,
            "%s.stepgen.%01d.counts", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (4); j++) {
        r = hal_pin_bit_newf(HAL_IN, &(inst->stepgen_enable[j]), comp_id,
            "%s.stepgen.%01d.enable", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (4); j++) {
        r = hal_pin_bit_newf(HAL_IN, &(inst->stepgen_reset[j]), comp_id,
            "%s.stepgen.%01d.reset", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (14); j++) {
        r = hal_pin_bit_newf(HAL_IN, &(inst->dout[j]), comp_id,
            "%s.dout.%02d", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (16); j++) {
        r = hal_pin_bit_newf(HAL_OUT, &(inst->din[j]), comp_id,
            "%s.din.%02d", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (16); j++) {
        r = hal_pin_bit_newf(HAL_OUT, &(inst->din_not[j]), comp_id,
            "%s.din.%02d-not", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (4); j++) {
        r = hal_param_float_newf(HAL_RW, &(inst->stepgen_scale[j]), comp_id,
            "%s.stepgen.%01d.scale", prefix, j);
        if(r != 0) return r;
    inst->stepgen_scale[j] = 1.0;
    }
    for(j=0; j < (4); j++) {
        r = hal_param_float_newf(HAL_RW, &(inst->stepgen_maxvel[j]), comp_id,
            "%s.stepgen.%01d.maxvel", prefix, j);
        if(r != 0) return r;
    inst->stepgen_maxvel[j] = 0;
    }
    r = hal_param_bit_newf(HAL_RW, &(inst->stepgen_step_polarity), comp_id,
        "%s.stepgen.step-polarity", prefix);
    if(r != 0) return r;
    r = hal_param_u32_newf(HAL_RW, &(inst->stepgen_steplen), comp_id,
        "%s.stepgen.steplen", prefix);
    if(r != 0) return r;
    r = hal_param_u32_newf(HAL_RW, &(inst->stepgen_stepspace), comp_id,
        "%s.stepgen.stepspace", prefix);
    if(r != 0) return r;
    r = hal_param_u32_newf(HAL_RW, &(inst->stepgen_dirtime), comp_id,
        "%s.stepgen.dirtime", prefix);
    if(r != 0) return r;
    for(j=0; j < (14); j++) {
        r = hal_param_bit_newf(HAL_RW, &(inst->dout_invert[j]), comp_id,
            "%s.dout.%02d-invert", prefix, j);
        if(r != 0) return r;
    }
    r = hal_param_u32_newf(HAL_RW, &(inst->communication_error), comp_id,
        "%s.communication-error", prefix);
    if(r != 0) return r;
    r = hal_param_s32_newf(HAL_RW, &(inst->debug_0), comp_id,
        "%s.debug-0", prefix);
    if(r != 0) return r;
    r = hal_param_s32_newf(HAL_RW, &(inst->debug_1), comp_id,
        "%s.debug-1", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->debug_2), comp_id,
        "%s.debug-2", prefix);
    inst->debug_2 = .5;
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->debug_3), comp_id,
        "%s.debug-3", prefix);
    inst->debug_3 = 2.0;
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s.transfer", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))transfer, inst, 1, 0, comp_id);
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s.spitest", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))spitest, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
int rtapi_app_main(void) {
    int r = 0;
    comp_id = hal_init("pluto_step_rpspi");
    if(comp_id < 0) return comp_id;
    r = export("pluto-step-rpspi", 0);
    if(r) {
    extra_cleanup();
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    extra_cleanup();
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef stepgen_position_cmd
#define stepgen_position_cmd(i) (0+*(__comp_inst->stepgen_position_cmd[i]))
#undef stepgen_velocity_fb
#define stepgen_velocity_fb(i) (*(__comp_inst->stepgen_velocity_fb[i]))
#undef stepgen_position_fb
#define stepgen_position_fb(i) (*(__comp_inst->stepgen_position_fb[i]))
#undef stepgen_counts
#define stepgen_counts(i) (*(__comp_inst->stepgen_counts[i]))
#undef stepgen_enable
#define stepgen_enable(i) (0+*(__comp_inst->stepgen_enable[i]))
#undef stepgen_reset
#define stepgen_reset(i) (0+*(__comp_inst->stepgen_reset[i]))
#undef dout
#define dout(i) (0+*(__comp_inst->dout[i]))
#undef din
#define din(i) (*(__comp_inst->din[i]))
#undef din_not
#define din_not(i) (*(__comp_inst->din_not[i]))
#undef stepgen_scale
#define stepgen_scale(i) (__comp_inst->stepgen_scale[i])
#undef stepgen_maxvel
#define stepgen_maxvel(i) (__comp_inst->stepgen_maxvel[i])
#undef stepgen_step_polarity
#define stepgen_step_polarity (__comp_inst->stepgen_step_polarity)
#undef stepgen_steplen
#define stepgen_steplen (__comp_inst->stepgen_steplen)
#undef stepgen_stepspace
#define stepgen_stepspace (__comp_inst->stepgen_stepspace)
#undef stepgen_dirtime
#define stepgen_dirtime (__comp_inst->stepgen_dirtime)
#undef dout_invert
#define dout_invert(i) (__comp_inst->dout_invert[i])
#undef communication_error
#define communication_error (__comp_inst->communication_error)
#undef debug_0
#define debug_0 (__comp_inst->debug_0)
#undef debug_1
#define debug_1 (__comp_inst->debug_1)
#undef debug_2
#define debug_2 (__comp_inst->debug_2)
#undef debug_3
#define debug_3 (__comp_inst->debug_3)
#undef data
#define data (*(internal*)(__comp_inst->_data))


#line 212 "pluto_step_rpspi.comp"



#include "rtapi.h"

#include "rtapi_bitops.h"

#include "rtapi_app.h"

#include "hal.h"



#define BUILD_SYS_USER_DSO

#define TARGET_PLATFORM_RASPBERRY



#if !defined(BUILD_SYS_USER_DSO)

#error "This driver is for usermode threads only"

#endif



#if !defined(TARGET_PLATFORM_RASPBERRY)

#error "This driver is for the Raspberry Pi platform only"

#endif





#define u32 unsigned int 

#define __u32 unsigned int



#define u16 unsigned short

#define __u16 unsigned short



 

#include <stdio.h>

#include <stdlib.h>

#include <stdint.h>

#include <math.h>

#include <fcntl.h>

#include <sys/mman.h>

#include <sys/types.h>

#include <sys/stat.h>

#include <unistd.h>

#include <errno.h>

#include <stdarg.h>



#include "pluto_common_rpspi.h"



volatile unsigned *gpio, *spi;

static volatile u32 txBuf[BUFSIZE], rxBuf[BUFSIZE];

static platform_t platform;



static int map_gpio();

static void setup_gpio();

static void restore_gpio();

static int pluto_program(char *);

platform_t check_platform(void);



static int speedrange=0;

RTAPI_MP_INT(speedrange, "Speed range 0..3");



#define PLUTO_SPEED_NS (1600)

#define PLUTO_SPEED    (PLUTO_SPEED_NS * 1e-9)

#define PLUTO_FREQ     (1e9 / PLUTO_SPEED_NS)

#define TMAX           ((1<<5)-1)



#define W 10

#define F 11

#define MODULO ((1<<(W+F))-1)

#define MASK ((1<<(W+F))-1)

#define MAXDELTA (MASK/2)



typedef struct {

	int64_t last_count[4];

	int64_t reset_count[4];

	double old_position_cmd[4];

	double old_velocity_cmd[4];

} internal;



#define ONE (1<<F)

//#define MAX_STEP_RATE ((1<<F)-1)
#define MAX_STEP_RATE (1<<(F-1))


EXTRA_SETUP() {

	int i, retval = 0;



	platform = check_platform();

	retval = map_gpio();

	if (retval < 0) {

		rtapi_print_msg(RTAPI_MSG_ERR,

		        "HAL_pluto_servo_rpspi: ERROR: cannot map GPIO memory\n");

		return retval;

	}



	if(firmware != "")

	{

		retval = pluto_program(firmware);

		if(retval < 0)

		{

			rtapi_print_msg(RTAPI_MSG_ERR,

					"HAL_pluto_servo_rpspi: ERROR: uploading firmware failed!!!\n");

			return retval;

		}

	}

        

	setup_gpio();



	return 0;

}



EXTRA_CLEANUP() {

	// reset the FPGA

	GPIO_CLR = 1<<25;

	usleep(1000);

	GPIO_SET = 1<<25;

	usleep(1000);



	if (gpio != MAP_FAILED && spi != MAP_FAILED) {

		

		restore_gpio();

		munmap((void *)gpio,BLOCK_SIZE);

		munmap((void *)spi,BLOCK_SIZE);

	}

}



FUNCTION(spitest) {

	char *buf;

	int i;

	__u32 spidata;

	

	for (i=0; i<BUFSIZE; i++) {

		txBuf[i] = i;

	}

	

	/* activate transfer */

//	BCM2835_SPICS = SPI_CS_TA|SPI_CS_CPHA|SPI_CS_CPOL;
//BCM2835_SPICS = SPI_CS_TA;


	/* send txBuf */

	/* RPi SPI transfers 8 bits at a time only */

	buf = (char *)txBuf;

	for (i=0; i<SPIBUFSIZE; i++) {

		BCM2835_SPIFIFO = *buf++;

	}



	/* wait until transfer is finished */

	while (!(BCM2835_SPICS & SPI_CS_DONE));



	/* clear DONE bit */

	BCM2835_SPICS = SPI_CS_DONE;



	/*****************************************************************************/

	/* read buffer */

	/* RPi SPI transfers 8 bits at a time only */

	buf = (char *)rxBuf;

	for (i=0; i<SPIBUFSIZE; i++) {

		*buf++ = BCM2835_SPIFIFO;

	}

	

	for (i=5; i<BUFSIZE; i++) {

		spidata = rxBuf[i];

	}

}

	

FUNCTION(transfer) {

	char *buf;

	__u16 * tbuf;

	

	int i;

	__u32 spidata;

	//rtapi_print_msg(RTAPI_MSG_ERR,
	//		"HAL_pluto_servo_rpspi: START transfer!!!\n");


	int r = 0;

	int stepspace_ticks = stepgen_stepspace/PLUTO_SPEED_NS;

	int steplen_ticks = stepgen_steplen/PLUTO_SPEED_NS;

	int dirtime_ticks = stepgen_dirtime/PLUTO_SPEED_NS;

	int rate, maxrate = MAX_STEP_RATE;

	double fmax;



	if(steplen_ticks > TMAX) {

		steplen_ticks = TMAX;

		rtapi_print_msg(RTAPI_MSG_ERR,

				"Requested step length %dns decreased to %dns "

				"due to hardware limitations\n",

				stepgen_steplen, TMAX * PLUTO_SPEED_NS);

		stepgen_steplen = TMAX * PLUTO_SPEED_NS;

	}



	if(dirtime_ticks > TMAX) {

		dirtime_ticks = TMAX;

		rtapi_print_msg(RTAPI_MSG_ERR,

				"Requested direction change time %dns decreased to %dns "

				"due to hardware limitations\n",

				stepgen_dirtime, TMAX * PLUTO_SPEED_NS);

		stepgen_dirtime = TMAX * PLUTO_SPEED_NS;

	}



	// Speed limits come from several sources

	// First limit: step waveform timings

	fmax = 1.0 / PLUTO_SPEED / (2 + steplen_ticks + stepspace_ticks);

	// Second limit: highest speed command

	if(fmax > PLUTO_FREQ / (2<<speedrange))

			fmax = PLUTO_SPEED * (2<<speedrange);

	// Third limit: max sign-extenable counts per period

	if(fmax > MAXDELTA / fperiod / (1<<speedrange))

			fmax = MAXDELTA / fperiod / (1<<speedrange);



	//if(communication_error) return;

	

	tbuf = (__u16 *)txBuf;

	for(i=0; i<4; i++) {

		double new_position_cmd = stepgen_position_cmd(i);

		double v = new_position_cmd - data.old_position_cmd[i];

		double est_err = stepgen_position_fb(i) + data.old_velocity_cmd[i] * fperiod - new_position_cmd;

		double actual_max;

		double scale_abs = fabs(stepgen_scale(i));



		v = v - debug_2 * est_err / fperiod;

		if(v > 0) v = v + .5/scale_abs;

		else if(v < 0) v = v - .5/scale_abs;



		data.old_position_cmd[i] = new_position_cmd;

		data.old_velocity_cmd[i] = v;

		actual_max = fmax / scale_abs;

		if(stepgen_maxvel(i) < 0) stepgen_maxvel(i) = -stepgen_maxvel(i);

		if(stepgen_maxvel(i) != 0 && stepgen_maxvel(i) > actual_max) {

			static int message_printed[4] = {0,0,0,0};

			if(!message_printed[i]) {

				rtapi_print_msg(RTAPI_MSG_ERR,

						"Requested step rate %dHz decreased to %dHz "

						"due to hardware or timing limitations\n",

						(int)(stepgen_maxvel(i) * scale_abs),

						(int)(fmax));

				message_printed[i] = 1;

			}

			stepgen_maxvel(i) = actual_max;

		}



		if(stepgen_maxvel(i) == 0) {

			if(v < -actual_max) v = -actual_max;

			if(v > actual_max) v = actual_max;

		}else {

			if(v < -stepgen_maxvel(i)) v = -stepgen_maxvel(i);

			if(v > stepgen_maxvel(i)) v = stepgen_maxvel(i);

		}

		rate = v*stepgen_scale(i)*ONE*PLUTO_SPEED/(1<<speedrange);



		if(rate > maxrate) rate = maxrate;

		if(rate < -maxrate) rate = -maxrate;



		if(!stepgen_enable(i)) rate = 0;

		//if(i == 0) debug_1 = rate;

		//if(!i%2)

		//	txBuf[i%2] = 0;

		//txBuf[i%2] |= rate<<(16*(i%2));

		tbuf[i] = rate;

	}



	r = 0;

	for(i=0; i<14; i++) {

		if(!dout(i) ^ !dout_invert(i)) r |= (1<<i);

	}

	txBuf[2] = r;

	r=0;

//	r = steplen_ticks | (dirtime_ticks << 8);
r = stepspace_ticks << 14 |  steplen_ticks << 8 | (dirtime_ticks );
	//r = steplen_ticks+stepspace_ticks | (dirtime_ticks << 8);

	if (stepgen_step_polarity) {

			r |= 0x0080;

	}else r &= 0xFF7F;

	txBuf[2] |= r<<16;

	

	for (i=3; i<BUFSIZE; i++) {

		txBuf[i] = i;

	}

	

	/* activate transfer */

	BCM2835_SPICS = SPI_CS_TA|SPI_CS_CPHA|SPI_CS_CPOL;
// BCM2835_SPICS = SPI_CS_TA;


	/* send txBuf */

	/* RPi SPI transfers 8 bits at a time only */

	buf = (char *)txBuf;

	for (i=0; i<SPIBUFSIZE; i++) {

		BCM2835_SPIFIFO = *buf++;

	}



	/* wait until transfer is finished */

	while (!(BCM2835_SPICS & SPI_CS_DONE));



	/* clear DONE bit */

	BCM2835_SPICS = SPI_CS_DONE|SPI_CS_CPHA|SPI_CS_CPOL;



	/*****************************************************************************/

	/* read buffer */

	/* RPi SPI transfers 8 bits at a time only */

	buf = (char *)rxBuf;

	for (i=0; i<SPIBUFSIZE; i++) {

		*buf++ = BCM2835_SPIFIFO;

	}

	

	for(i=0; i<4; i++) {

		int64_t count;

		double fcount;

		int newlow;

		int reset;

		

		spidata = rxBuf[i];

		

		reset = stepgen_reset(i);

		newlow = spidata & MASK;

		count = extend(data.last_count[i], newlow, W+F);

		stepgen_velocity_fb(i) = (count-data.last_count[i])/stepgen_scale(i)/fperiod/(1<<F);

		data.last_count[i] = count;

		if(reset) data.reset_count[i] = count;

		fcount = (count-data.reset_count[i])*1.0/(1<<F);

		stepgen_counts(i) = fcount;

		stepgen_position_fb(i) = fcount/stepgen_scale(i);





		if(i == 0) {

		//		debug_0 = spidata;

			debug_1 = newlow;

		}

	}



	spidata = rxBuf[4];

	debug_0 = spidata; //din

	//debug_1 = spidata;



	for(i=0; i< 16; i++) {

		int b = spidata & (1<<i);

		din(i) = !!b;

		din_not(i) = !b;

	}

	

	for (i=5; i<BUFSIZE; i++) {

		spidata = rxBuf[i];

	}

	//rtapi_print_msg(RTAPI_MSG_ERR,
	//		"HAL_pluto_servo_rpspi: END transfer!!!\n");

}



int map_gpio() {

	int fd;

	static u32 mem_base, mem_spi_base;



	switch (platform) {

	case RPI:

		mem_base = BCM2835_GPIO_BASE;

		mem_spi_base = BCM2835_SPI_BASE;

		break;

	case RPI_2:

		mem_base = BCM2835_GPIO_BASE + BCM2709_OFFSET;

		mem_spi_base = BCM2835_SPI_BASE + BCM2709_OFFSET;

		break;

	default:
		rtapi_print_msg(RTAPI_MSG_ERR,
			"HAL_pluto_servo_rpspi: Not Support!!\n");
		break;

	}



	fd = rtapi_open_as_root("/dev/mem", O_RDWR | O_SYNC);

	if (fd < 0) {

		rtapi_print_msg(RTAPI_MSG_ERR,"HAL_pluto_servo_rpspi: can't open /dev/mem \n");

		return -1;

	}



	/* mmap GPIO */

	gpio = mmap(

	        NULL,

	        BLOCK_SIZE,

	        PROT_READ|PROT_WRITE,

	        MAP_SHARED,

	        fd,

	        mem_base);



	/* mmap SPI */

	spi = mmap(

	        NULL,

	        BLOCK_SIZE,

	        PROT_READ|PROT_WRITE,

	        MAP_SHARED,

	        fd,

	        mem_spi_base);



	close(fd);



	if (gpio == MAP_FAILED) {

		rtapi_print_msg(RTAPI_MSG_ERR,"HAL_pluto_servo_rpspi: can't map gpio\n");

		return -2;

	}



	if (spi == MAP_FAILED) {

		rtapi_print_msg(RTAPI_MSG_ERR,"HAL_pluto_servo_rpspi: can't map spi\n");

		return -3;

	}



	return 0;

}



void setup_gpio() {

	uint32_t x;



	/* change SPI pins */

	x = BCM2835_GPFSEL0;

	//x &= ~(0b111 << (7*3) | 0b111 << (8*3) | 0b111 << (9*3));

	//x |= (0b001 << (7*3) | 0b100 << (8*3) | 0b100 << (9*3));	// GPIO pin7 output, pin8 pin9 alternate0 (SPI)

	x &= ~(0b111 << (8*3) | 0b111 << (9*3));

	x |= (0b100 << (8*3) | 0b100 << (9*3));	// pin8 pin9 alternate0 (SPI)

	BCM2835_GPFSEL0 = x;



	x = BCM2835_GPFSEL1;

	x &= ~(0b111 << (0*3) | 0b111 << (1*3));

	x |= (0b100 << (0*3) | 0b100 << (1*3));	// pin10 pin11 alternate0 (SPI)

	BCM2835_GPFSEL1 = x;



	/* set up SPI */

//	BCM2835_SPICLK = (1 << SPICLKDIV);
BCM2835_SPICLK=200;


	BCM2835_SPICS = 0;



	/* clear FIFOs */

	BCM2835_SPICS |= SPI_CS_CLEAR_RX | SPI_CS_CLEAR_TX;



	/* clear done bit */

	BCM2835_SPICS |= SPI_CS_DONE;

}



void restore_gpio() {

	uint32_t x;



	/* change SPI pins to inputs*/

	x = BCM2835_GPFSEL0;

	//x &= ~(0b111 << (7*3) | 0b111 << (8*3) | 0b111 << (9*3));

	x &= ~(0b111 << (8*3) | 0b111 << (9*3));

	BCM2835_GPFSEL0 = x;



	x = BCM2835_GPFSEL1;

	x &= ~(0b111 << (0*3) | 0b111 << (1*3));

	BCM2835_GPFSEL1 = x;

}



#define FIRMWARE_SIZE 19895

static int pluto_program(char *firmware) {

	int byte, bit;

	int i;

	FILE *f;

	int size = 0;

	

	f= fopen(firmware, "rb");

	if(!f) {

		rtapi_print_msg(RTAPI_MSG_ERR, "fopen-Error\n");

		return -EIO;

	}

	if(fseek(f, 0, SEEK_END))

	{

		rtapi_print_msg(RTAPI_MSG_ERR, "fseek-Error!\n");

		return -EIO;

	}

	size = ftell(f);

	rewind(f);

	rtapi_print_msg(RTAPI_MSG_INFO, "Filesize: %d Bytes\n", size);

	if(size != FIRMWARE_SIZE)

	{

		rtapi_print_msg(RTAPI_MSG_ERR, "Incorrect filesize!!\n");

		return -EIO;

	}

	unsigned char buf[size];

	if(fread(buf, 1, size, f) != FIRMWARE_SIZE) {

		rtapi_print_msg(RTAPI_MSG_ERR,"fread-Error!\n");

		return -EIO;

	}

	

		/***************************/

	/** Just a extra tuition	**/ 

	uint32_t x;

	/* setup GPIO 25 as OUTPUT connected to Data2 on Pluto (internal nRESET) */

	x = BCM2835_GPFSEL2;		// (25/10)

	x &= ~(0b111 << (5*3));	// (25%10*3)

	x |= (0b001 << (5*3));	// pin25 OUTPUT

	BCM2835_GPFSEL2 = x;

	

	/* setup GPIO 24 as INPUT connected to nPaperOut on Pluto */

	x = BCM2835_GPFSEL2;		// (24/10)

	x &= ~(0b111 << (4*3));	// (24%10*3) pin24 INPUT

	BCM2835_GPFSEL2 = x;

	/***************************/

	

	// Set GPIO pins 8-11 to output for Pluto Programming (CE0, MISO, MOSI, SCKL)

	for (i=8; i<=11; i++)

	{

		INP_GPIO(i); // must use INP_GPIO before we can use OUT_GPIO

		OUT_GPIO(i);

	}

	

	

	// reset the FPGA in advance

	GPIO_CLR = 1<<25;

	usleep(1000);

	GPIO_SET = 1<<25;

	usleep(1000);

	

		rtapi_print_msg(RTAPI_MSG_ERR,"uploading pluto-spi-firmware...\n");



	// pull the reset low -- bit 2 of Control register

	// keep it low 2 microseconds

	for(i=0; i<12; i++) GPIO_CLR = 1<<8;	//outb(0, ioaddr+2);



	// let it go high again

	// delay 10 microseconds to guarantee nStatus high

	for(i=0; i<40; i++) GPIO_SET = 1<<8;	//outb(4, ioaddr+2);



	// Now program the device...

	for(byte = 0; byte < FIRMWARE_SIZE; byte++) {

		for(bit = 0; bit < 8; bit++) {

			int v = buf[byte] & (1<<bit);

			if(v) GPIO_SET = 1<<10; else GPIO_CLR = 1<<10;

			for(i=0; i<22; i++) GPIO_CLR = 1<<11;		//outb(0|4, ioaddr+2);

			

			for(i=0; i<22; i++) GPIO_SET = 1<<11;		//outb(1|4, ioaddr+2);

			

				for(i=0; i<22; i++) GPIO_CLR = 1<<11;

		}

	}

	rtapi_print_msg(RTAPI_MSG_ERR,"...done\n");

}



platform_t check_platform(void)

{

	FILE *fp;

	char buf[2048];

	size_t fsize;
	platform_t rv;



	fp = fopen("/proc/cpuinfo", "r");

	fsize = fread(buf, 1, sizeof(buf), fp);

	fclose(fp);

	

	if (fsize == 0 || fsize == sizeof(buf))

		return 0;



	/* NUL terminate the buffer */

	buf[fsize] = '\0';



	if (NULL != strstr(buf, "BCM2708"))

		return RPI;

	else if (NULL != strstr(buf, "BCM2709"))

		return RPI_2;
	else if (NULL != strstr(buf, "BCM2835")){
		char *rev_val = strstr(buf, "Revision");
		if(rev_val) {
			char *rev_start = strstr(rev_val, ": ");
			unsigned long rev = strtol(rev_start + 2, NULL, 16);

			if(rev <= 0xffff)
				rv = RPI; // pre pi2 revision scheme
			else {
				switch((rev & 0xf000) >> 12) {
				case 0: //bcm2835
					rv = RPI;
					break;
				case 1: //bcm2836
				case 2: //bcm2837
					rv = RPI_2;	// peripheral base is same on pi2/3
					break;
				default:
					break;
				}
			}
		}
	}

	else

		return UNSUPPORTED;
	return RPI_2;

}
static int __comp_get_data_size(void) { return sizeof(internal); }
